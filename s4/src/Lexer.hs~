module Lexer where

import Text.Parsec (ParseError, between, string, many1, space, parseTest, spaces, try, count, parse, eof, choice, manyTill, chainl1) 
import Text.Parsec.String (Parser)
import Text.Parsec.Char (char, digit, hexDigit, noneOf, oneOf, anyChar, letter)
import Data.Char
import Control.Applicative
import Control.Monad


 

data Instr = 
    MRep Expr [Instr]
  | Color String 
  | Rep Expr Instr
  | Back Expr
  | LeftI Expr
  | RightI Expr
  | Down
  | Up 
  | Forw Expr deriving (Show, Eq)


data Expr = 
    Num Integer 
   | Add Expr Expr 
   | Parens Expr 
   | Min Expr Expr 
   | Mul Expr Expr 
   | Div Expr Expr
   | Var String deriving (Show, Eq)


instr :: Parser Instr
instr = try color 
        <|> up 
        <|> forw 
        <|> back 
        <|> down 
        <|> choice [try mrep, try rep, try right]
        <|> left


lexeme :: Parser a -> Parser a
lexeme p = p <* whitespace

mrep :: Parser Instr
mrep = lexeme $ do
  string "rep" 
  many1 space 
  e <- expr 
  many1 space
  i <- between (char '\"') (char '\"') (many instr)
  return (MRep e i)

rep :: Parser Instr
rep = lexeme $do
  string "rep" *> many1 space 
  e <- expr 
  many1 space 
  i <- instr
  return (Rep e i)

up :: Parser Instr
up = lexeme $ string "up" *> spaces *> char '.' *> spaces *> return Up

down :: Parser Instr
down = lexeme $ string "down" *> spaces *> char '.' *> spaces *> return Down

forw :: Parser Instr
forw = lexeme $ do
  string "forw" *> many1 space 
  num <- expr 
  spaces
  char '.'
  spaces
  return (Forw num) 

right :: Parser Instr
right = lexeme $ do
  string "right" *> many1 space 
  num <- expr 
  spaces
  char '.'
  spaces
  return (RightI num) 

left :: Parser Instr
left = lexeme $ do
  string "left" *> many1 space 
  num <- expr 
  spaces
  char '.'
  spaces
  return (LeftI num) 

back :: Parser Instr
back = lexeme $ do
  string "back" *> many1 space 
  num <- expr 
  spaces 
  char '.'
  spaces
  return (Back num) 

color :: Parser Instr
color = lexeme $ do
  c <- string "color" *> whitespace *> char '#'
  code <- count 6 hexDigit 
  char '.' 
  spaces
  return (Color code)

num :: Parser Expr
num = (Num . read) <$> (many1 digit)


var :: Parser Expr
var = Var <$> iden
  where
    iden = lexeme ((:) <$> firstChar <*> many nonFirstChar)
    firstChar = letter <|> char '_' <|> char '='
    nonFirstChar = digit <|> firstChar
    
parens :: Parser Expr
parens =
    Parens <$> (lexeme (char '(')
                *> expr
                <* lexeme (char ')'))

term :: Parser Expr
term = num <|> parens <|> var

expr :: Parser Expr
expr = chainl1 term op
  where op = (Add <$ lexeme (char '+')) 
             <|> (Mul <$ lexeme (char '*')) 
             <|> (Div <$ lexeme (char '/')) 
             <|> (Min <$ lexeme (char '-'))


createTokens :: String -> Either ParseError [Instr] 
createTokens = parse (whitespace *> many instr <* eof) ""

whitespace :: Parser ()
whitespace = choice [comment *> whitespace,
                     simpleWhitespace *> whitespace,
                     return ()]

simpleWhitespace = void $ many1 (oneOf " \t\n")
comment = void (try (string "%") *>
                              manyTill anyChar (void (char '\n') <|> eof))
