
==================== FINAL INTERFACE ====================
2016-05-08 13:55:07.381115 UTC

interface s4_5a036ccoHUe9tzKFXgbNQT:LexerTest 7103
  interface hash: 84cf425f20d8d9985a5f9c2b35268aec
  ABI hash: 50444ad8308312f4fc9834f689e8db71
  export-list hash: 2dd325e16665d33e40f9bdbb5ec1cef3
  orphan hash: fff5f1d1bb719007816d2d5a3c34193f
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  LexerTest.back
  LexerTest.color
  LexerTest.createTokens
  LexerTest.def
  LexerTest.down
  LexerTest.exprparser
  LexerTest.forw
  LexerTest.instrparser
  LexerTest.left
  LexerTest.m_dot
  LexerTest.m_hexadecimal
  LexerTest.m_identifier
  LexerTest.m_lexeme
  LexerTest.m_parens
  LexerTest.m_reserved
  LexerTest.m_reservedOp
  LexerTest.m_semiSep1
  LexerTest.m_whiteSpace
  LexerTest.mainparser
  LexerTest.mrep
  LexerTest.num
  LexerTest.rep
  LexerTest.right
  LexerTest.table
  LexerTest.term
  LexerTest.up
  LexerTest.var
  LexerTest.Expr{LexerTest.Add LexerTest.Div LexerTest.Mul LexerTest.Neg LexerTest.Num LexerTest.Pos LexerTest.Sub LexerTest.Var}
  LexerTest.Instr{LexerTest.:= LexerTest.Back LexerTest.Color LexerTest.Down LexerTest.Forw LexerTest.LeftI LexerTest.MRep LexerTest.Rep LexerTest.RightI LexerTest.Up}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl
                      text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
import  -/  base-4.8.2.0:Control.Applicative a8ebf5ad4932b411ad7725da68be9801
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec 26c7a351136ae5dd73df2f4f17f69ff8
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Char 273c4e73468dedca710570316c08a761
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Combinator 8d413b3f12710d25023c38cebce7eb58
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Error f845543d816de25a8de00e4137afe6b2
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Expr 74c953b1a60444019fbd97533fb68d31
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Language 050edbf20111bd6896772d23eab8c7e1
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Prim 1f699e694859aece3e0612a4d0e0177b
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.String 194037aaf0f54cd34cf205eead33954d
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Token 08adccfb70cf8f729a4b2d5fc4848cbb
92349a48b0399252179fd8bc8c87da5a
  $fEqExpr :: GHC.Classes.Eq LexerTest.Expr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Expr LexerTest.$fEqExpr_$c== LexerTest.$fEqExpr_$c/= -}
92349a48b0399252179fd8bc8c87da5a
  $fEqExpr_$c/= :: LexerTest.Expr -> LexerTest.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: LexerTest.Expr b :: LexerTest.Expr ->
                 case LexerTest.$fEqExpr_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
92349a48b0399252179fd8bc8c87da5a
  $fEqExpr_$c== :: LexerTest.Expr -> LexerTest.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
f8e483b4833234c8defc6c8757c1841f
  $fEqInstr :: GHC.Classes.Eq LexerTest.Instr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Instr
                  LexerTest.$fEqInstr_$c==
                  LexerTest.$fEqInstr_$c/= -}
f8e483b4833234c8defc6c8757c1841f
  $fEqInstr_$c/= ::
    LexerTest.Instr -> LexerTest.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: LexerTest.Instr b :: LexerTest.Instr ->
                 case LexerTest.$fEqInstr_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f8e483b4833234c8defc6c8757c1841f
  $fEqInstr_$c== ::
    LexerTest.Instr -> LexerTest.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
92349a48b0399252179fd8bc8c87da5a
  $fShowExpr :: GHC.Show.Show LexerTest.Expr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Expr
                  LexerTest.$fShowExpr_$cshowsPrec
                  LexerTest.$fShowExpr_$cshow
                  LexerTest.$fShowExpr_$cshowList -}
92349a48b0399252179fd8bc8c87da5a
  $fShowExpr1 :: LexerTest.Expr -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: LexerTest.Expr w1 :: GHC.Base.String ->
                 LexerTest.$w$cshowsPrec 0 w w1) -}
92349a48b0399252179fd8bc8c87da5a
  $fShowExpr_$cshow :: LexerTest.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: LexerTest.Expr ->
                 LexerTest.$fShowExpr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
92349a48b0399252179fd8bc8c87da5a
  $fShowExpr_$cshowList :: [LexerTest.Expr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ LexerTest.Expr
                   LexerTest.$fShowExpr1) -}
92349a48b0399252179fd8bc8c87da5a
  $fShowExpr_$cshowsPrec ::
    GHC.Types.Int -> LexerTest.Expr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: LexerTest.Expr w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 LexerTest.$w$cshowsPrec ww1 w1 w2 }) -}
f8e483b4833234c8defc6c8757c1841f
  $fShowInstr :: GHC.Show.Show LexerTest.Instr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Instr
                  LexerTest.$fShowInstr_$cshowsPrec
                  LexerTest.$fShowInstr_$cshow
                  LexerTest.$fShowInstr_$cshowList -}
f8e483b4833234c8defc6c8757c1841f
  $fShowInstr1 :: LexerTest.Instr -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (LexerTest.$fShowInstr_$cshowsPrec
                   LexerTest.$fShowInstr2) -}
cabcc833a2ff33e1b42501c6efcf6eaa
  $fShowInstr2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
f8e483b4833234c8defc6c8757c1841f
  $fShowInstr_$cshow :: LexerTest.Instr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: LexerTest.Instr ->
                 LexerTest.$fShowInstr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f8e483b4833234c8defc6c8757c1841f
  $fShowInstr_$cshowList :: [LexerTest.Instr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ LexerTest.Instr
                   LexerTest.$fShowInstr1) -}
f8e483b4833234c8defc6c8757c1841f
  $fShowInstr_$cshowsPrec ::
    GHC.Types.Int -> LexerTest.Instr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
7c82415e60998380b33657df74f57ba1
  $sread :: GHC.Base.String -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 case Text.Read.readEither
                        @ GHC.Types.Int
                        GHC.Read.$fReadInt
                        s of wild {
                   Data.Either.Left x -> GHC.Err.error @ GHC.Types.Int x
                   Data.Either.Right y -> y }) -}
92349a48b0399252179fd8bc8c87da5a
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> LexerTest.Expr -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
6eb998a914c8fc5b7b425cff80fadf02
  $wa ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0],
     Unfolding: (\ @ b1
                   w :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w1 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa9
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Instr
                   LexerTest.createTokens6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr>_R))
                   @ b1
                   w
                   (\ x :: [LexerTest.Instr] -> w1 (\ ds :: () -> x))
                   w2
                   (\ x :: [LexerTest.Instr] -> w3 (\ ds :: () -> x))) -}
92349a48b0399252179fd8bc8c87da5a
  data Expr
    = Num GHC.Types.Int
    | Var GHC.Base.String
    | Neg LexerTest.Expr
    | Pos LexerTest.Expr
    | Add LexerTest.Expr LexerTest.Expr
    | Sub LexerTest.Expr LexerTest.Expr
    | Mul LexerTest.Expr LexerTest.Expr
    | Div LexerTest.Expr LexerTest.Expr
f8e483b4833234c8defc6c8757c1841f
  data Instr
    = Rep LexerTest.Expr LexerTest.Instr
    | MRep LexerTest.Expr [LexerTest.Instr]
    | GHC.Base.String := LexerTest.Expr
    | Forw LexerTest.Expr
    | Back LexerTest.Expr
    | LeftI LexerTest.Expr
    | RightI LexerTest.Expr
    | Color GHC.Base.String
    | Up
    | Down
24665fbe95fbead1dd86fbe276b30079
  back :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.back1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
a43f6e7243c9127dadf6c13548140bcb
  back1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ LexerTest.Expr
                   LexerTest.back2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> LexerTest.Expr>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (LexerTest.Back x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (LexerTest.Back x))
                   eerr) -}
01db401d162cb06f1589697e3bef84fa
  back2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Expr
                   LexerTest.back7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (\ ds :: GHC.Base.String -> x))
                   eerr) -}
165bbddac37b8653c9667f08a7415f56
  back3 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Prim.<?>1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   LexerTest.back5
                   LexerTest.back4) -}
c339c6d513385e8c51a44490821362ff
  back4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "expression"#) -}
086aa1cf30ccec9acf1a586b168360be
  back5 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Unfolding: (Text.Parsec.Expr.buildExpressionParser1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table @ ())
                   LexerTest.back6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))) -}
f3326e2efa0c93c90d38b1a889d6d1bb
  back6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)> -}
a4dd0b6b1de23cf889bd050a07ccd34d
  back7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ LexerTest.Expr))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ LexerTest.Expr))
                   eta6) -}
f18d49ddfc4fb7f6bd41af938c20da0a
  back_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def16 }) -}
da5e2f4c866b5d07e798e85b8e4325f5
  color :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.color1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
c3716305e04ac3aca7da0cecf72466c9
  color1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ GHC.Base.String
                   LexerTest.color2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> GHC.Base.String>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (LexerTest.Color x))
                   cerr
                   (\ x :: GHC.Base.String -> eok (LexerTest.Color x))
                   eerr) -}
a8a4331d1bb377fd0a6e5723d1ca9878
  color10 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '#') -}
f513ea7b902bc50c1184b66adb8a4894
  color11 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.color_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ GHC.Types.Char))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ GHC.Types.Char))
                   eta6) -}
ddb4faefd70450b6fa63e77babf356bc
  color2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> GHC.Base.String)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> GHC.Base.String)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ GHC.Base.String
                   LexerTest.color7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> GHC.Base.String>_R))
                   LexerTest.color3
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: GHC.Base.String -> eok (\ ds :: GHC.Base.String -> x))
                   eerr) -}
3f99f836ec512511fecf2347743a8f8d
  color3 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity [GHC.Types.Char]
  {- Unfolding: (Text.Parsec.Combinator.$wlvl
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   6
                   LexerTest.color4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))) -}
4c1d195ed3505d6b684dc8563c24a38b
  color4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.color6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.color5
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
ec3b4aa9e6cef144883173a9b2c155ab
  color5 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.hexDigit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
008a6b8751fd1439cfd91be886170320
  color6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isHexDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
daa9c1be9a1cc045c107e591e4551b0d
  color7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl23 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ GHC.Base.String)
                 } in
                 let {
                   lvl24 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ GHC.Base.String)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   LexerTest.color11
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char -> GHC.Types.Char>_R))
                   LexerTest.color8
                   @ b1
                   eta2
                   (\ x :: GHC.Types.Char -> lvl24)
                   eta4
                   (\ x :: GHC.Types.Char -> lvl23)
                   eta6) -}
eb70495f60bd57c068057ca764e010c4
  color8 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14 @ GHC.Types.Char LexerTest.color9 }) -}
a05391ea56077d460a4ad76f09802efe
  color9 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.color10) -}
0c91ed03d08a59194af604bcc1940f5e
  color_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def11 }) -}
ec457e112acb9d0458428147a04634d1
  createTokens ::
    GHC.Base.String
    -> Data.Either.Either
         Text.Parsec.Error.ParseError [LexerTest.Instr]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Data.Functor.Identity.NTCo:Identity[0]
                          <Data.Either.Either
                             Text.Parsec.Error.ParseError [LexerTest.Instr]>_R) -}
7370f4b848ea1d3fbf1511119ba0e84a
  createTokens1 ::
    GHC.Base.String
    -> Data.Functor.Identity.Identity
         (Data.Either.Either Text.Parsec.Error.ParseError [LexerTest.Instr])
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s1 :: GHC.Base.String ->
                 Text.Parsec.Prim.runPT
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [LexerTest.Instr]
                   @ GHC.Types.Char
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.createTokens3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[LexerTest.Instr]>_R))
                   GHC.Tuple.()
                   LexerTest.createTokens2
                   s1) -}
6d129bcc197f55bd7bc0794181f8b0aa
  createTokens2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "(stdin)"#) -}
e23863f2e2330fbea6482afc6b368b2e
  createTokens3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ([LexerTest.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([LexerTest.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: [LexerTest.Instr]
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: [LexerTest.Instr]
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds15
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Prim.$wa
                      @ [GHC.Types.Char]
                      @ ()
                      @ Data.Functor.Identity.Identity
                      @ ()
                      @ [LexerTest.Instr]
                      LexerTest.createTokens5
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <[GHC.Types.Char]>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <() -> [LexerTest.Instr]>_R))
                      LexerTest.createTokens4
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <GHC.Base.String>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <()>_R))
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: [LexerTest.Instr]
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Prim.$wa
                      @ [GHC.Types.Char]
                      @ ()
                      @ Data.Functor.Identity.Identity
                      @ ()
                      @ [LexerTest.Instr]
                      LexerTest.createTokens5
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <[GHC.Types.Char]>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <() -> [LexerTest.Instr]>_R))
                      LexerTest.createTokens4
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <GHC.Base.String>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <()>_R))
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: [LexerTest.Instr]
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4 }) -}
a52dbb3f37d8437e85a757df17f9bda0
  createTokens4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Combinator.eof1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Show.$fShowChar) -}
a003bed064a85455abf912f20692b7b0
  createTokens5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   w :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w1 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.$wa @ b1 w w1 w2 w3) -}
36d6458c81d61c166a1f4f0340f1dcdf
  createTokens6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
af97e93461bbd9f783af6b2bfe39be7f
  def ::
    Text.Parsec.Token.GenLanguageDef
      GHC.Base.String u Data.Functor.Identity.Identity
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Token.LanguageDef
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   LexerTest.def28
                   LexerTest.def27
                   LexerTest.def28
                   GHC.Types.True
                   (LexerTest.def24 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (LexerTest.def21 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (LexerTest.def19 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Text.Parsec.Language.emptyDef1 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.def3
                   LexerTest.def1
                   GHC.Types.False) -}
1e2252a4e726b753f5f8c6a70557f305
  def1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def2
                   (GHC.Types.[] @ GHC.Base.String)) -}
7731e191b40cd8a8a1fda921cafe587c
  def10 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def11
                   (GHC.Types.[] @ GHC.Base.String)) -}
5659f59886ea24a3ebabb6d2926a66e7
  def11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "color"#) -}
8cbc3620b7fd9910a034d2edf93761fb
  def12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "down"#) -}
673df85cc816d03ddef96b2eeea8b9f6
  def13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "up"#) -}
b0bb548310ef38d713af13cee7901b02
  def14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "right"#) -}
71c8fbed725d342ff35fd351f76bd3d4
  def15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "left"#) -}
560ce9b17f55e5586c5f194304dea458
  def16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "back"#) -}
15ecc73a3667510c07782f23a79322a0
  def17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "forw"#) -}
d37a0323ccae2eceb7a2538e1189d4da
  def18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rep"#) -}
e0e46cc254bab7b5fd8e7872426c3990
  def19 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.def20
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w4 } }) -}
e03a81a7bdd9b4c55864b98a281843db
  def2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
0775d1b702473fa1d76c998dbf0960ba
  def20 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   LexerTest.def2) -}
7315917daa79ec97b8c014531169049e
  def21 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ u
                   @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String u
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (LexerTest.def23 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.def22
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
a2d398230521b393e6a476dc126a34ad
  def22 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.alphaNum2
                   (GHC.Types.[] @ GHC.Base.String)) -}
d8abad12f96c0e312e0bc675299c1f77
  def23 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ u
                   @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String u[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isAlphaNum
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
e821c336aab7c86326db39ae4142d823
  def24 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ u
                   @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String u
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (LexerTest.def26 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.def25
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
db4bfaf69498db157ddace0f26f53001
  def25 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.letter2
                   (GHC.Types.[] @ GHC.Base.String)) -}
c4d0e2b9c9a3a75636bdbb0e4a9cf41b
  def26 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ u
                   @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String u[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isAlpha
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
fc4e8438762b8571c7fd91b5ec8445cb
  def27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
1728be624ffed9e3a845b6acc9b05ade
  def28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%"#) -}
98b1d494205415678becf1b963750e97
  def3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def18
                   LexerTest.def4) -}
802a0cfbc1fcc17008860c420d0360e6
  def4 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def17
                   LexerTest.def5) -}
249799181128b2d04a876684ce014050
  def5 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def16
                   LexerTest.def6) -}
1b0fecf068785ec4f53ac6665fa26c77
  def6 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def15
                   LexerTest.def7) -}
4ddb1639db1bccbe5dc7740c38fde084
  def7 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def14
                   LexerTest.def8) -}
f11a54de422c4a520286bd9b611208c8
  def8 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def13
                   LexerTest.def9) -}
3e7fc8c057f494c34afe4afc1507ddd3
  def9 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def12
                   LexerTest.def10) -}
f73cb361e0091b9a19855c6f293a7ced
  down :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.down1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
e4f9489a1aeca16fc92b9d8c5d092526
  down1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Instr
                   @ LexerTest.Instr
                   LexerTest.down3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr -> LexerTest.Instr>_R))
                   LexerTest.down2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
59992503be1be11afcbdedc31985d097
  down2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(U,U,U)><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   ds :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   ds1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b ->
                 eok
                   LexerTest.Down
                   s1
                   (case s1 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                    Text.Parsec.Error.ParseError
                      ds4
                      (GHC.Types.[] @ Text.Parsec.Error.Message) })) -}
ca220428e9704c56cc50071e9e949ee3
  down3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Instr -> LexerTest.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Instr -> LexerTest.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl23 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ LexerTest.Instr)
                 } in
                 let {
                   lvl24 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ LexerTest.Instr)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ GHC.Base.String
                   LexerTest.down4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> GHC.Base.String>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl24)
                   eta4
                   (\ x :: GHC.Base.String -> lvl23)
                   eta6) -}
e82a3312a566a378695bc8fce0fd4ea5
  down4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.down_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ GHC.Base.String))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ GHC.Base.String))
                   eta6) -}
84975cfd9448ad1fc4cd515e08802ed4
  down_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def12 }) -}
4902e33ca82ea78848ebfac7326088e7
  exprparser :: Text.Parsec.String.Parser LexerTest.Expr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                LexerTest.back3
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
65db0b006a32f23f04363db36bcbc1ee
  forw :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.forw1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
6a8de8cca9ea4b7f7bc369a5fce9ab5c
  forw1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ LexerTest.Expr
                   LexerTest.forw2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> LexerTest.Expr>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (LexerTest.Forw x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (LexerTest.Forw x))
                   eerr) -}
b847f03ea602f36fa0b515f8d29981dc
  forw2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Expr
                   LexerTest.forw3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (\ ds :: GHC.Base.String -> x))
                   eerr) -}
a2f9c2ddbd4532506d06d405deec162f
  forw3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.forw_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ LexerTest.Expr))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ LexerTest.Expr))
                   eta6) -}
0a45098bea9f84ea39701ff0596aec47
  forw_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def17 }) -}
c60ecae5555bc2e67a1d8874b90ce868
  instrparser :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens6
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
4ef5d251cd3e13dbe072a6329b619317
  left :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.left1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
bec82f8394f1fdd04a14eb2ece38f298
  left1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ LexerTest.Expr
                   LexerTest.left2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> LexerTest.Expr>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (LexerTest.LeftI x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (LexerTest.LeftI x))
                   eerr) -}
3bdf25c3491019ca3d97f192a46e17c9
  left2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Expr
                   LexerTest.left3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (\ ds :: GHC.Base.String -> x))
                   eerr) -}
f234ca59bb10c8b87cdb33563bd58a69
  left3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.left_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ LexerTest.Expr))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ LexerTest.Expr))
                   eta6) -}
c1cb1b00edc91574e723a997ede7b383
  left_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def15 }) -}
eb8a67806432bf8d41597bd4bdffd720
  m_dot ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds24 }) -}
0a05441224cca93a51688283b5a48ea7
  m_dot1 ::
    Text.Parsec.Token.GenTokenParser
      GHC.Base.String t Data.Functor.Identity.Identity
  {- Unfolding: (\ @ t ->
                 Text.Parsec.Token.makeTokenParser
                   @ GHC.Base.String
                   @ t
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   (LexerTest.def @ t)) -}
93531eaf3a9d863444c57fa572f174a5
  m_hexadecimal ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String
      t
      Data.Functor.Identity.Identity
      GHC.Integer.Type.Integer
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds11 }) -}
3ed48b393f3220dbb0ee575b5d10882b
  m_identifier ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds }) -}
0d436dd2f86a4303938d2e4fa1eb1e34
  m_lexeme ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14 }) -}
cc46ef0a9c9f1cf8a53e1865dd7bd552
  m_parens ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds16 }) -}
bb9aaeffa7a55d952e7fb2e34b13ba15
  m_reserved ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 }) -}
65cd2deb195b97c847aa9972747a8f16
  m_reservedOp ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 }) -}
aee422a68e455699335661da593e8c20
  m_semiSep1 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity [a]
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds26 }) -}
ee581487762bce4c898cf0e0f0a52673
  m_whiteSpace ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.m_dot1
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds15 }) -}
b8c28641b0ad6ea210d67350e1e58ce6
  mainparser :: Text.Parsec.String.Parser [LexerTest.Instr]
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens3
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <[LexerTest.Instr]>_R)) -}
f204aa7c412af16298745578fd4fc5ee
  mrep :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.mrep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
105db7b848e9deaf1f368f4f274285b9
  mrep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
15261f47a3682fbd07e52c7ab750ff16
  mrep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep4
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
26762c69a426447e83351929dc154db0
  mrep3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
35c8e1ceda10a02789df1406e5f0ad92
  mrep4 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14
                   @ LexerTest.Expr
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R)) }) -}
f2431a9a37149ec3bbac7a4a6dc41fde
  mrep_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def18 }) -}
b0306565f94d166627aa7ba842d7b174
  num :: Text.Parsec.String.Parser LexerTest.Expr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.num1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
9d6fa7bdd2ed85f6bf596a9e8ede5f15
  num1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.num2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   s1
                   (\ x :: GHC.Base.String ->
                    cok (LexerTest.Num (LexerTest.$sread x)))
                   cerr
                   (\ x :: GHC.Base.String ->
                    eok (LexerTest.Num (LexerTest.$sread x)))
                   eerr) -}
5d3d3719af9af9eebb16a745ea019905
  num2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.num4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.num3
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
0ef705a744cef804e7dd81774db4a60c
  num3 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.digit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
accacb3febe5ffadb7cc2f647fe5fc8d
  num4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
8cff86421d8c929e814e0273a4d240f9
  rep :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.rep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
6ed17331f1e5335324c0919a634294cd
  rep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Instr
                   @ LexerTest.Instr
                   LexerTest.rep2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr -> LexerTest.Instr>_R))
                   LexerTest.createTokens6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
b0b86236dfcf0d478a17ec4253dcd236
  rep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (LexerTest.Instr -> LexerTest.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (LexerTest.Instr -> LexerTest.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ LexerTest.Expr
                   LexerTest.rep3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> LexerTest.Expr>_R))
                   (LexerTest.m_whiteSpace @ ())
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (LexerTest.Rep x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (LexerTest.Rep x))
                   eerr) -}
4d150e4e6eecc86e66fe70b66cd0f354
  rep3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (() -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (() -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Expr
                   LexerTest.rep4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: () -> x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (\ ds :: () -> x))
                   eerr) -}
0f15dacd65216e953ae5bc34504d960d
  rep4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ LexerTest.Expr))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ LexerTest.Expr))
                   eta6) -}
6da70e70279c355fa6162e6830d3341d
  right :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.right1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
f1252cb3cce1031fa10e20f7c221d2b2
  right1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ LexerTest.Expr
                   LexerTest.right2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> LexerTest.Expr>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (LexerTest.RightI x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (LexerTest.RightI x))
                   eerr) -}
7227b63b5acd5941bd5fbbd00adb0ba6
  right2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Expr
                   LexerTest.right3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))
                   LexerTest.back3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: LexerTest.Expr -> eok (\ ds :: GHC.Base.String -> x))
                   eerr) -}
5fd0c510f85af5bc829ea5a79ad840af
  right3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.right_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ LexerTest.Expr))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ LexerTest.Expr))
                   eta6) -}
00f454ae1b3ce3856918128271bcd021
  right_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def14 }) -}
835d385336615eb4c514ffd07f791005
  table ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table19 @ u)
                   (LexerTest.table1 @ u)) -}
2e4d2ba9afdbfdfcc4c786aa532f5427
  table1 ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table11 @ u)
                   (LexerTest.table2 @ u)) -}
8b3f6add69f8cf8096d32d20f8914eb7
  table10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "+"#) -}
5f0b337020520a6f5ff57649ace4dad7
  table11 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table16 @ u)
                   (LexerTest.table12 @ u)) -}
eed6cdac055a503b0532eb3f7edbf85d
  table12 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table13 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
85146f0649c88868928d0bb77e031333
  table13 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table14 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
4914a9b44d6cf900da672fe878a03fa6
  table14 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m3 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
4052baa5ec7148b374725fe53573a362
  table15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "/"#) -}
13c19779103c8600900527c357f07ce0
  table16 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table17 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
dd98ec913e1bfb13ca68b4482fa57268
  table17 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m4 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Mul
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Mul
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
2c50d40fde00d5f959cd9f07e84c457f
  table18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "*"#) -}
044c8ba7a6955ae08f8d5aea03ec8ebf
  table19 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table23 @ u)
                   (LexerTest.table20 @ u)) -}
5b93955a043aec4f9eb64afb8508ba45
  table2 ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table3 @ u)
                   (GHC.Types.[]
                      @ [Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr])) -}
cbf230b2fb81f8ac4022b80008db4940
  table20 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table21 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
e84cbbfdd4c9a8e9e5854aabaa344d41
  table21 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Prefix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table22 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))) -}
992d1bb84fb84a814408675a373f0453
  table22 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m2 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Pos
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Pos
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
0bedb64afdcbe07ad1e3a6b86005f184
  table23 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Prefix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table24 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))) -}
7ea37220157dcb37ea7cb087aa5b1f82
  table24 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m1 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
de0995bf795878a6929d11b70538b4e1
  table3 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table8 @ u)
                   (LexerTest.table4 @ u)) -}
5f5921e399a0072b91149b4040d16990
  table4 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table5 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
103a6692a0443d334593620e0b958246
  table5 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
4b4af2e48bbced04f59c37c60d11d18f
  table6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m1 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
072ba262dbcf8cf557d3a758c79bcba9
  table7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-"#) -}
6bc3f52c532d8c905fdcca173c561125
  table8 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table9 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
fd5681461b3aff2e304b4917d9615e37
  table9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m2 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
dbf647b6202da7ebd89088d263851daf
  table_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.m_dot1
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table7 }) -}
4e130d8cc14870baf34c70310cffa7dd
  table_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.m_dot1
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table10 }) -}
c08475bae9cc4d7330acf1571e2bd5e3
  table_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.m_dot1
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table15 }) -}
735de16b41a2725f7ecb4f284abce074
  table_m4 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.m_dot1
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table18 }) -}
82db011590ed8891123f9561f5dcf632
  term ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.back6
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
65f5666b6960b8c07c11f6fc2279621c
  up :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.up1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
03acaae95e6c51bb76b1aa457c149426
  up1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Instr
                   @ LexerTest.Instr
                   LexerTest.up3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr -> LexerTest.Instr>_R))
                   LexerTest.up2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
a848385b622c31e3bc9efff9bb19b765
  up2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(U,U,U)><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   ds :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   ds1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eok :: LexerTest.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b ->
                 eok
                   LexerTest.Up
                   s1
                   (case s1 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                    Text.Parsec.Error.ParseError
                      ds4
                      (GHC.Types.[] @ Text.Parsec.Error.Message) })) -}
e0554462ef9a7e02ab4d790e3f5d2c46
  up3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Instr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (LexerTest.Instr -> LexerTest.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (LexerTest.Instr -> LexerTest.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl23 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ LexerTest.Instr)
                 } in
                 let {
                   lvl24 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ LexerTest.Instr)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ GHC.Base.String
                   LexerTest.up4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> GHC.Base.String>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl24)
                   eta4
                   (\ x :: GHC.Base.String -> lvl23)
                   eta6) -}
dc43aaf074f208e82a38761450d0c3cd
  up4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Base.String -> GHC.Base.String)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.up_eta1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta2
                   (\ x :: () -> eta3 (GHC.Base.id @ GHC.Base.String))
                   eta4
                   (\ x :: () -> eta5 (GHC.Base.id @ GHC.Base.String))
                   eta6) -}
f985441191b659569b275423446834ed
  up_eta1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def13 }) -}
67090ca2341515251bbccef905d20ce4
  var :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.var1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
816956c42ca59caad1ebbf6ff68db9a4
  var1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   @ LexerTest.Instr
                   LexerTest.var4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Instr>_R))
                   LexerTest.var2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
09318c9c4042ef83052120189f94f84b
  var2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: LexerTest.Expr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: LexerTest.Expr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Base.String
                   @ LexerTest.Expr
                   LexerTest.var3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String -> LexerTest.Expr>_R))
                   (LexerTest.m_dot @ ())
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
ef18f3a5d3372ba474b8266ab6323d35
  var3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Base.String -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(U)><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (GHC.Base.String -> LexerTest.Expr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back5
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   s1
                   (\ x :: LexerTest.Expr -> cok (\ ds :: GHC.Base.String -> x))
                   cerr
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    eok
                      (\ ds :: GHC.Base.String -> x)
                      s'
                      (case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                       case msgs1 of wild1 {
                         [] -> wild
                         : ds1 ds2
                         -> case Text.Parsec.Prim.$wsetExpectErrors
                                   _pos
                                   wild1
                                   LexerTest.var_msgs of ww { (#,#) ww1 ww2 ->
                            Text.Parsec.Error.ParseError ww1 ww2 } } }))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eerr
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.var_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
a5d7c55e4b78f5076658b74418d59e1e
  var4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((LexerTest.Expr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (LexerTest.Expr -> LexerTest.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (LexerTest.Expr -> LexerTest.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ GHC.Base.String
                   LexerTest.var6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> GHC.Base.String>_R))
                   LexerTest.var5
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (LexerTest.:= x))
                   cerr
                   (\ x :: GHC.Base.String -> eok (LexerTest.:= x))
                   eerr) -}
a22db117534c0225f818ae56d648409e
  var5 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.def2 }) -}
b249535088a14047f7f8e58f79ddaf12
  var6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> GHC.Base.String)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (() -> GHC.Base.String)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (() -> GHC.Base.String)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 case LexerTest.m_dot1
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (\ ds29 :: () -> x))
                   cerr
                   (\ x :: GHC.Base.String -> eok (\ ds29 :: () -> x))
                   eerr }) -}
2c883811bcd4a580e806006c939a4d25
  var_msgs :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.back4
                   (GHC.Types.[] @ GHC.Base.String)) -}
instance GHC.Classes.Eq [LexerTest.Expr] = LexerTest.$fEqExpr
instance GHC.Classes.Eq [LexerTest.Instr] = LexerTest.$fEqInstr
instance GHC.Show.Show [LexerTest.Expr] = LexerTest.$fShowExpr
instance GHC.Show.Show [LexerTest.Instr] = LexerTest.$fShowInstr
"SPEC/LexerTest read @ Int" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                        GHC.Types.Int
  Text.Read.read @ GHC.Types.Int $dRead = LexerTest.$sread
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

