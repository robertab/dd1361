
==================== FINAL INTERFACE ====================
2016-05-06 05:56:47.302546 UTC

interface s4_CNAlJoOMahpLIiI8ONUcw6:LexerTest 7103
  interface hash: bad5af1daa5c08f665ce54eab3068842
  ABI hash: 5ffff9616f41e2459f33b268f762fe3b
  export-list hash: b148b40d9cd71f4c21a2d6c4aaa4a6f9
  orphan hash: c5e6fd868bbfb1362c4885168768a7b2
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  LexerTest.back
  LexerTest.color
  LexerTest.createTokens
  LexerTest.def
  LexerTest.down
  LexerTest.exprparser
  LexerTest.forw
  LexerTest.instrparser
  LexerTest.left
  LexerTest.m_dot
  LexerTest.m_hexadecimal
  LexerTest.m_identifier
  LexerTest.m_lexeme
  LexerTest.m_parens
  LexerTest.m_reserved
  LexerTest.m_reservedOp
  LexerTest.m_semiSep1
  LexerTest.m_whiteSpace
  LexerTest.mainparser
  LexerTest.mrep
  LexerTest.num
  LexerTest.rep
  LexerTest.right
  LexerTest.table
  LexerTest.term
  LexerTest.up
  LexerTest.var
  LexerTest.Expr{LexerTest.Add LexerTest.Div LexerTest.Mul LexerTest.Neg LexerTest.Num LexerTest.Sub LexerTest.Var}
  LexerTest.Instr{LexerTest.:= LexerTest.Back LexerTest.Color LexerTest.Down LexerTest.Forw LexerTest.LeftI LexerTest.MRep LexerTest.Rep LexerTest.RightI LexerTest.Up}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl
                      text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
import  -/  base-4.8.2.0:Control.Applicative a8ebf5ad4932b411ad7725da68be9801
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec 26c7a351136ae5dd73df2f4f17f69ff8
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Char 273c4e73468dedca710570316c08a761
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Combinator 8d413b3f12710d25023c38cebce7eb58
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Error f845543d816de25a8de00e4137afe6b2
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Expr 74c953b1a60444019fbd97533fb68d31
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Language 050edbf20111bd6896772d23eab8c7e1
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Prim 1f699e694859aece3e0612a4d0e0177b
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.String 194037aaf0f54cd34cf205eead33954d
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Token 08adccfb70cf8f729a4b2d5fc4848cbb
93d427f723d09a63c6e8fb242d664e2f
  $fEqExpr :: GHC.Classes.Eq LexerTest.Expr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Expr LexerTest.$fEqExpr_$c== LexerTest.$fEqExpr_$c/= -}
93d427f723d09a63c6e8fb242d664e2f
  $fEqExpr_$c/= :: LexerTest.Expr -> LexerTest.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: LexerTest.Expr b :: LexerTest.Expr ->
                 case LexerTest.$fEqExpr_$c== a7 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
93d427f723d09a63c6e8fb242d664e2f
  $fEqExpr_$c== :: LexerTest.Expr -> LexerTest.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e7102260a83a114804ca7c8f7468e397
  $fEqInstr :: GHC.Classes.Eq LexerTest.Instr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Instr
                  LexerTest.$fEqInstr_$c==
                  LexerTest.$fEqInstr_$c/= -}
e7102260a83a114804ca7c8f7468e397
  $fEqInstr_$c/= ::
    LexerTest.Instr -> LexerTest.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: LexerTest.Instr b :: LexerTest.Instr ->
                 case LexerTest.$fEqInstr_$c== a7 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e7102260a83a114804ca7c8f7468e397
  $fEqInstr_$c== ::
    LexerTest.Instr -> LexerTest.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
93d427f723d09a63c6e8fb242d664e2f
  $fShowExpr :: GHC.Show.Show LexerTest.Expr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Expr
                  LexerTest.$fShowExpr_$cshowsPrec
                  LexerTest.$fShowExpr_$cshow
                  LexerTest.$fShowExpr_$cshowList -}
93d427f723d09a63c6e8fb242d664e2f
  $fShowExpr1 :: LexerTest.Expr -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: LexerTest.Expr w1 :: GHC.Base.String ->
                 LexerTest.$w$cshowsPrec 0 w w1) -}
93d427f723d09a63c6e8fb242d664e2f
  $fShowExpr_$cshow :: LexerTest.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: LexerTest.Expr ->
                 LexerTest.$fShowExpr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
93d427f723d09a63c6e8fb242d664e2f
  $fShowExpr_$cshowList :: [LexerTest.Expr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ LexerTest.Expr
                   LexerTest.$fShowExpr1) -}
93d427f723d09a63c6e8fb242d664e2f
  $fShowExpr_$cshowsPrec ::
    GHC.Types.Int -> LexerTest.Expr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: LexerTest.Expr w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 LexerTest.$w$cshowsPrec ww1 w1 w2 }) -}
e7102260a83a114804ca7c8f7468e397
  $fShowInstr :: GHC.Show.Show LexerTest.Instr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ LexerTest.Instr
                  LexerTest.$fShowInstr_$cshowsPrec
                  LexerTest.$fShowInstr_$cshow
                  LexerTest.$fShowInstr_$cshowList -}
e7102260a83a114804ca7c8f7468e397
  $fShowInstr1 :: LexerTest.Instr -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (LexerTest.$fShowInstr_$cshowsPrec
                   LexerTest.$fShowInstr2) -}
bbf8d8c4d2f6a364e2be1c58c5e612db
  $fShowInstr2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
e7102260a83a114804ca7c8f7468e397
  $fShowInstr_$cshow :: LexerTest.Instr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: LexerTest.Instr ->
                 LexerTest.$fShowInstr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e7102260a83a114804ca7c8f7468e397
  $fShowInstr_$cshowList :: [LexerTest.Instr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ LexerTest.Instr
                   LexerTest.$fShowInstr1) -}
e7102260a83a114804ca7c8f7468e397
  $fShowInstr_$cshowsPrec ::
    GHC.Types.Int -> LexerTest.Instr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
214f1b6938e2f7b13ccbbf7138034f09
  $sread :: GHC.Base.String -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 case Text.Read.readEither
                        @ GHC.Types.Int
                        GHC.Read.$fReadInt
                        s of wild {
                   Data.Either.Left x -> GHC.Err.error @ GHC.Types.Int x
                   Data.Either.Right y -> y }) -}
93d427f723d09a63c6e8fb242d664e2f
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> LexerTest.Expr -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
608d563b263abb4b4acd7457d4c74368
  $wa ::
    GHC.Base.String
    -> Text.Parsec.Pos.SourceName
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0] -}
b1b85fb6fff0797cb55d95f5ac6a771e
  $wa1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0],
     Unfolding: (\ @ b1
                   w :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w1 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa9
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Instr
                   LexerTest.createTokens6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Instr>_R))
                   @ b1
                   w
                   (\ x :: [LexerTest.Instr] -> w1 (\ ds :: () -> x))
                   w2
                   (\ x :: [LexerTest.Instr] -> w3 (\ ds :: () -> x))) -}
c20ed8587a3334163c07be7e43dce939
  $wa2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 4, Strictness: <L,U(U,U,U)><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: [0] -}
93d427f723d09a63c6e8fb242d664e2f
  data Expr
    = Num GHC.Types.Int
    | Var GHC.Base.String
    | Neg LexerTest.Expr
    | Add LexerTest.Expr LexerTest.Expr
    | Sub LexerTest.Expr LexerTest.Expr
    | Mul LexerTest.Expr LexerTest.Expr
    | Div LexerTest.Expr LexerTest.Expr
e7102260a83a114804ca7c8f7468e397
  data Instr
    = Rep LexerTest.Expr [LexerTest.Instr]
    | MRep LexerTest.Expr [LexerTest.Instr]
    | GHC.Base.String := LexerTest.Expr
    | Forw LexerTest.Expr
    | Back LexerTest.Expr
    | LeftI LexerTest.Expr
    | RightI LexerTest.Expr
    | Color GHC.Base.String
    | Up
    | Down
c25c06f5bc8f9cc11ced514fdce6ac9d
  back :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.back1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
2e1b38ddd21b118a19dcf73b4c8227aa
  back1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.back2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.back2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
bfe76cfd0a646352654286a95425b9d8
  back2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back6
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.back4
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    let {
                      err :: Text.Parsec.Error.ParseError
                      = case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                        case msgs1 of wild1 {
                          [] -> wild
                          : ds1 ds2
                          -> case Text.Parsec.Prim.$wsetExpectErrors
                                    _pos
                                    wild1
                                    LexerTest.back_msgs of ww { (#,#) ww1 ww2 ->
                             Text.Parsec.Error.ParseError ww1 ww2 } } }
                    } in
                    LexerTest.back4
                      x
                      @ b1
                      s'
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eta4
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.back_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
27899a8864474e5f61e73644dec856ef
  back3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "expression"#) -}
a327438bf23e0001399cbd9e48a8655b
  back4 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ e :: LexerTest.Expr
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 let {
                   x :: LexerTest.Instr = LexerTest.Back e
                 } in
                 ds24
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b
                   eta
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
37644607d3c9aa36a1f622fd86adf7e2
  back5 ::
    Text.Parsec.Token.GenTokenParser
      GHC.Base.String t Data.Functor.Identity.Identity
  {- Unfolding: (\ @ t ->
                 Text.Parsec.Token.makeTokenParser
                   @ GHC.Base.String
                   @ t
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   (LexerTest.def @ t)) -}
05e0b21fafa45a3308f2fd5cf98c34fb
  back6 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Unfolding: (Text.Parsec.Expr.buildExpressionParser1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table @ ())
                   LexerTest.back7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R))) -}
e8457637d2ef7b43e18212c9b5c384c3
  back7 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)> -}
869383491cbf2b0c8df8fc8012ab2c78
  back_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def22 }) -}
3b46bbdaf4c188251d52dbab0426eee9
  back_msgs :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.back3
                   (GHC.Types.[] @ GHC.Base.String)) -}
be00ecace520d40787edad648bdfc990
  color :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.color1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
c93096a282c832ff963b9f452f23e40f
  color1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.color_m2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
a50191973bb9876b55ff3b2466557eb7
  color2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.color_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Types.Char>_R)
                   @ b1
                   eta
                   (\ x :: GHC.Types.Char
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color3
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: GHC.Types.Char
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color3
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
97aee21380ebd1725fee0cd16af394b4
  color3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.color_p
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <[GHC.Types.Char]>_R)
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color4
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.color4
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
1eccec43f38cfc48802ddfd4bf4ba58e
  color4 ::
    [GHC.Types.Char]
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ c :: [GHC.Types.Char]
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 let {
                   x :: LexerTest.Instr = LexerTest.Color c
                 } in
                 ds24
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b
                   eta
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
844b40afb5f7e56c4e0501a387e3149d
  color5 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.color7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.color6
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
f224e3ea31bd986bfcdc6a2a4edd343c
  color6 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.hexDigit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
57c4f59cc1d78870f27d7a3d36d79980
  color7 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isHexDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
e68321ab356449868c9be4f0273aada8
  color8 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.color9) -}
a37e2b226b4842c8351392cfdebbd330
  color9 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '#') -}
7701fd4076199d130b2f0041d0cdaf3b
  color_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14 @ GHC.Types.Char LexerTest.color8 }) -}
510513877fb575ad20fd147d6213cd08
  color_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def17 }) -}
e5017d72a00589aaab8fc0c9795af023
  color_p ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity [GHC.Types.Char]
  {- Unfolding: (Text.Parsec.Combinator.$wlvl
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   6
                   LexerTest.color5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))) -}
efd03c28cd14112c527a27662e950ada
  createTokens ::
    GHC.Base.String
    -> Data.Either.Either
         Text.Parsec.Error.ParseError [LexerTest.Instr]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Data.Functor.Identity.NTCo:Identity[0]
                          <Data.Either.Either
                             Text.Parsec.Error.ParseError [LexerTest.Instr]>_R) -}
bbe95169a2cb14c6b4d3d18e41e9fd26
  createTokens1 ::
    GHC.Base.String
    -> Data.Functor.Identity.Identity
         (Data.Either.Either Text.Parsec.Error.ParseError [LexerTest.Instr])
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s1 :: GHC.Base.String ->
                 Text.Parsec.Prim.runPT
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [LexerTest.Instr]
                   @ GHC.Types.Char
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.createTokens3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[LexerTest.Instr]>_R))
                   GHC.Tuple.()
                   LexerTest.createTokens2
                   s1) -}
ef29a0b4d83aea14663ba57d2d91d03b
  createTokens2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "(stdin)"#) -}
544c411cc71b8cf70eba0e5f50bf87d3
  createTokens3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ([LexerTest.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([LexerTest.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: [LexerTest.Instr]
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: [LexerTest.Instr]
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds15
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Prim.$wa
                      @ [GHC.Types.Char]
                      @ ()
                      @ Data.Functor.Identity.Identity
                      @ ()
                      @ [LexerTest.Instr]
                      LexerTest.createTokens5
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <[GHC.Types.Char]>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <() -> [LexerTest.Instr]>_R))
                      LexerTest.createTokens4
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <GHC.Base.String>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <()>_R))
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: [LexerTest.Instr]
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Prim.$wa
                      @ [GHC.Types.Char]
                      @ ()
                      @ Data.Functor.Identity.Identity
                      @ ()
                      @ [LexerTest.Instr]
                      LexerTest.createTokens5
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <[GHC.Types.Char]>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <() -> [LexerTest.Instr]>_R))
                      LexerTest.createTokens4
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <GHC.Base.String>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <()>_R))
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: [LexerTest.Instr]
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4 }) -}
5d0d5234f76934977c36434624a2d1a0
  createTokens4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Combinator.eof1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Show.$fShowChar) -}
101337925fc4218cbb514204e647eefd
  createTokens5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> [LexerTest.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ b1
                   w :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w1 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: (() -> [LexerTest.Instr])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.$wa1 @ b1 w w1 w2 w3) -}
050c0524f52935309856a36395a08dae
  createTokens6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,A><L,C(C1(C1(U)))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String ()
                   w1 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: LexerTest.Instr
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 LexerTest.$wa2 @ b w w1 w3 w4) -}
cbf6000e55437ae7e894f50396145d0d
  def ::
    Text.Parsec.Token.GenLanguageDef
      GHC.Base.String u Data.Functor.Identity.Identity
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Token.LanguageDef
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   LexerTest.def33
                   LexerTest.def32
                   (GHC.Types.[] @ GHC.Types.Char)
                   GHC.Types.True
                   (LexerTest.def31 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (LexerTest.def28 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (LexerTest.def25 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Text.Parsec.Language.emptyDef1 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.def9
                   LexerTest.def1
                   GHC.Types.False) -}
458d9afea6408f601aeb17af0ed45dee
  def1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def8
                   LexerTest.def2) -}
8a78d27da81bfe5489caa128e6ad8652
  def10 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def23
                   LexerTest.def11) -}
0112e42831e00c6512d21cc81a26fa48
  def11 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def22
                   LexerTest.def12) -}
6e705ab14f637dde692948a3fbe92cb9
  def12 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def21
                   LexerTest.def13) -}
385ff969232fa52cee8a771ce3b3d1c7
  def13 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def20
                   LexerTest.def14) -}
53c944109aaa8e2912d6029f72c55899
  def14 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def19
                   LexerTest.def15) -}
26556352e4f6243328a4bfa5fc968636
  def15 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def18
                   LexerTest.def16) -}
1a5b5453e953a5a344c3db95a8e10943
  def16 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def17
                   (GHC.Types.[] @ GHC.Base.String)) -}
0a6adcbcf7e57d69d87a109c4f3b072e
  def17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "color"#) -}
0bf232ffcb57ad5c032400b15f4a01d2
  def18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "down"#) -}
305d8c1e4e70d3bf80775f3239d63e6f
  def19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "up"#) -}
5335edc021ff8158be93959a148d8cf3
  def2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def7
                   LexerTest.def3) -}
2a3534312abe7cbae5bebf2ba2705883
  def20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "right"#) -}
782bdc6d5cb9001bdf1d3713ee0f4a65
  def21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "left"#) -}
90ad96d7ca0fff7c22da4cf9e7869be3
  def22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "back"#) -}
29bc41e4cd159092df1e55f80d92a291
  def23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "forw"#) -}
b894364ad84aa802ed9f780d33970a9d
  def24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rep"#) -}
9cdd82796cb0b44a35e64f9b73423544
  def25 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   LexerTest.def26
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w4 } }) -}
eda3db663d142c552c4cbd0345b08041
  def26 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   LexerTest.def27) -}
583334cb6a07aa7f7611f818e4c1fd77
  def27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=\"#"#) -}
5dea7a51c9abfd54cdb8306107d25334
  def28 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ u
                   @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String u
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (LexerTest.def30 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.def29
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
0deeff706b2a0f84946fd98c0103231d
  def29 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.alphaNum2
                   (GHC.Types.[] @ GHC.Base.String)) -}
576dde0e9a7c5ddca1ad658465f15b6f
  def3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def6
                   LexerTest.def4) -}
04ee57123763b48fca7f04ff25c0f153
  def30 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ u
                   @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String u[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isAlphaNum
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
71e7e02139c10b135215d50dcec50f30
  def31 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 LexerTest.$wa @ u @ b ww1 ww5 ww6 ww7 ww3 w1 w2 w3 w4 } }) -}
cf58437906f7fa21282435583561e624
  def32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
377a908bad5c906ec8c4539e35c0bbb8
  def33 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%"#) -}
1cb7ea1e1ea4e7579e5bdfef31915a37
  def4 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def5
                   (GHC.Types.[] @ GHC.Base.String)) -}
da528669699505cc45e38b7655fd0c90
  def5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "#"#) -}
4c9cdb5720e178cc4c3d6907161da58e
  def6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\""#) -}
3ba5308b48cd0e681552ce442795c627
  def7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ":="#) -}
df81cffc9352d7dc7f1cee9a53efd093
  def8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
9068dc91dcce550d1aa425fffd536097
  def9 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LexerTest.def24
                   LexerTest.def10) -}
43a736c69a5679ba383ae792b062b262
  down :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.down1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
61ea32b98c7ab4cb3348bf38d0592b1f
  down1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
0bbac5b95240306f9bef58d9aecce4d1
  exprparser :: Text.Parsec.String.Parser LexerTest.Expr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                LexerTest.exprparser1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
d98e5c53e565ec1de8067483d9660f21
  exprparser1 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Prim.<?>1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   LexerTest.back6
                   LexerTest.back3) -}
098cb06797b47fe76983b57ab175de25
  forw :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.forw1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
35d60ab326bb86fc084e8e507ce3b096
  forw1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.forw_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.forw2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.forw2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
2c1bc2e67c5f74744ce5dda7d197ca1b
  forw2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back6
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.forw3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    let {
                      err :: Text.Parsec.Error.ParseError
                      = case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                        case msgs1 of wild1 {
                          [] -> wild
                          : ds1 ds2
                          -> case Text.Parsec.Prim.$wsetExpectErrors
                                    _pos
                                    wild1
                                    LexerTest.back_msgs of ww { (#,#) ww1 ww2 ->
                             Text.Parsec.Error.ParseError ww1 ww2 } } }
                    } in
                    LexerTest.forw3
                      x
                      @ b1
                      s'
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eta4
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.back_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
e8aa69d51aed3e8e67564de20c17db0a
  forw3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ e :: LexerTest.Expr
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 let {
                   x :: LexerTest.Instr = LexerTest.Forw e
                 } in
                 ds24
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b
                   eta
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
c30a928548cfedfedee7baaacf18d6c5
  forw_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def23 }) -}
d8dd346e90b3ef19db657f5436dcc8ef
  instrparser :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,A><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens6
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
fa9696f0c029b8c043419ecb2a51190e
  left :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.left1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
42a81da7b2517718cedad13ac8c25edd
  left1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.left_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.left2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.left2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
8223b5ad1593aaca49f5b0d60d23e92f
  left2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back6
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.left3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    let {
                      err :: Text.Parsec.Error.ParseError
                      = case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                        case msgs1 of wild1 {
                          [] -> wild
                          : ds1 ds2
                          -> case Text.Parsec.Prim.$wsetExpectErrors
                                    _pos
                                    wild1
                                    LexerTest.back_msgs of ww { (#,#) ww1 ww2 ->
                             Text.Parsec.Error.ParseError ww1 ww2 } } }
                    } in
                    LexerTest.left3
                      x
                      @ b1
                      s'
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eta4
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.back_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
95b7e53cb6d9bebb99ac71192756c299
  left3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ e :: LexerTest.Expr
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 let {
                   x :: LexerTest.Instr = LexerTest.LeftI e
                 } in
                 ds24
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b
                   eta
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
d03918956d57bf0ef1fbf6d21df4ef44
  left_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def21 }) -}
4c1f17b174ec15c37303721ecc3de773
  m_dot ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds24 }) -}
5540260075f426ce8399d1a4e6ecb51e
  m_hexadecimal ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String
      t
      Data.Functor.Identity.Identity
      GHC.Integer.Type.Integer
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds11 }) -}
97bdd1c0e1910a58e4677b13ab9612be
  m_identifier ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity GHC.Base.String
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds }) -}
16988920bdf153db582395e1e8c66b4f
  m_lexeme ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14 }) -}
607a242ed3c86294a5a959c452a3df0a
  m_parens ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity a
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds16 }) -}
98297296f1f8adb8b8b30e1002514992
  m_reserved ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 }) -}
dd389e872a86b90b67e10081b0ba87af
  m_reservedOp ::
    GHC.Base.String
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 }) -}
e4d6f95c6e59aacb7e7a6446bd673fa0
  m_semiSep1 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity a
    -> Text.Parsec.Prim.ParsecT
         GHC.Base.String t Data.Functor.Identity.Identity [a]
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds26 }) -}
d101a5f11450c60fe5a170214ea7c2f9
  m_whiteSpace ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String t Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ t ->
                 case LexerTest.back5
                        @ t of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds15 }) -}
98da95168fc619ef877cd8d0a75844ae
  mainparser :: Text.Parsec.String.Parser [LexerTest.Instr]
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.createTokens3
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <[LexerTest.Instr]>_R)) -}
2a3da01b2d95417efeef43f43179c9fa
  mrep :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.mrep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
89122e565f804908d19b5d5ffe3d0fc8
  mrep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
228f88bbe43508fc5a49b3f31ce6e42d
  mrep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep4
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.mrep3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
d8916efcfe33d70d3b8cd2ded5d97de1
  mrep3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
2b20a01023d168cfffaf57abce02cc87
  mrep4 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds14
                   @ LexerTest.Expr
                   LexerTest.exprparser1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr>_R)) }) -}
a3bd8edf4149871bc131124128ed4fc7
  mrep_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def24 }) -}
a02bc34e5102cff4a79c8c4e2d898873
  num :: Text.Parsec.String.Parser LexerTest.Expr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.num1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
c489e2916fc44c8df347d696d505492b
  num1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: LexerTest.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: LexerTest.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.num2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   s1
                   (\ x :: GHC.Base.String ->
                    cok (LexerTest.Num (LexerTest.$sread x)))
                   cerr
                   (\ x :: GHC.Base.String ->
                    eok (LexerTest.Num (LexerTest.$sread x)))
                   eerr) -}
c66622460bdf669ecb7816fe3b7f383c
  num2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   LexerTest.num4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   LexerTest.num3
                   @ b
                   eta
                   eta1
                   eta2
                   eta3
                   eta4) -}
0e5fe50a1fb4e8e0333984ddc22d2ff4
  num3 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.digit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
950c972bef2d23c7e4334f9c5a136ffa
  num4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.Language.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
2a16772544afe3e5d782f27a1b3a89f8
  rep :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.rep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
13256d7fba506682157d47fb530e9a67
  rep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.mrep_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.rep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.rep2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
2f2525f0d488153ae103ddfbb56da636
  rep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back6
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.rep3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    let {
                      err :: Text.Parsec.Error.ParseError
                      = case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                        case msgs1 of wild1 {
                          [] -> wild
                          : ds1 ds2
                          -> case Text.Parsec.Prim.$wsetExpectErrors
                                    _pos
                                    wild1
                                    LexerTest.back_msgs of ww { (#,#) ww1 ww2 ->
                             Text.Parsec.Error.ParseError ww1 ww2 } } }
                    } in
                    LexerTest.rep3
                      x
                      @ b1
                      s'
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eta4
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.back_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
0048f883ebd87d9c3d26cb27ab668fb8
  rep3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ e :: LexerTest.Expr
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 LexerTest.createTokens3
                   @ b
                   eta
                   (\ x :: [LexerTest.Instr]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta1
                      (LexerTest.Rep e x)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: [LexerTest.Instr]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    eta3
                      (LexerTest.Rep e x)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
d13ea6f324d6b9d0560339c73f979ec2
  right :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.right1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
2b0a692b4a3ab5a9712ce4e612326bd2
  right1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.right_m1
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.right2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.right2
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4) -}
6ea060a7a797cae2028bae91df4f85f9
  right2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 LexerTest.back6
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <LexerTest.Expr>_R)
                   @ b1
                   eta
                   (\ x :: LexerTest.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.right3
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: LexerTest.Expr
                      s' :: Text.Parsec.Prim.State GHC.Base.String ()
                      error :: Text.Parsec.Error.ParseError ->
                    let {
                      err :: Text.Parsec.Error.ParseError
                      = case error of wild { Text.Parsec.Error.ParseError _pos msgs1 ->
                        case msgs1 of wild1 {
                          [] -> wild
                          : ds1 ds2
                          -> case Text.Parsec.Prim.$wsetExpectErrors
                                    _pos
                                    wild1
                                    LexerTest.back_msgs of ww { (#,#) ww1 ww2 ->
                             Text.Parsec.Error.ParseError ww1 ww2 } } }
                    } in
                    LexerTest.right3
                      x
                      @ b1
                      s'
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   (\ err :: Text.Parsec.Error.ParseError ->
                    eta4
                      (case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case Text.Parsec.Prim.$wsetExpectErrors
                              ww1
                              ww2
                              LexerTest.back_msgs of ww3 { (#,#) ww4 ww5 ->
                       Text.Parsec.Error.ParseError ww4 ww5 } }))) -}
120ec5fdefd2076d696a2ca50e600d1f
  right3 ::
    LexerTest.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ e :: LexerTest.Expr
                   @ b
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 let {
                   x :: LexerTest.Instr = LexerTest.RightI e
                 } in
                 ds24
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b
                   eta
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x1 :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      x
                      s2
                      (case s2 of wild1 { Text.Parsec.Prim.State ds29 ds30 ds31 ->
                       case ds30 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4 }) -}
73806fa47305da58cc509310987cefc1
  right_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity ()
  {- Unfolding: (case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds1 LexerTest.def20 }) -}
27c6a00635c999b41018695680a1b839
  table ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table19 @ u)
                   (LexerTest.table1 @ u)) -}
1c8c87e28a051c322db4de70195bc43e
  table1 ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table11 @ u)
                   (LexerTest.table2 @ u)) -}
4978c4fe39a3040d142f0c3ad2e600b3
  table10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "+"#) -}
43055d346cedf1f0248f9cd63283e8c6
  table11 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table16 @ u)
                   (LexerTest.table12 @ u)) -}
1c117e88541fa60b96e4626729857ce5
  table12 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table13 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
9ce3c2cac40466cf5af3a5f483167e7b
  table13 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table14 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
60ecf5314bcfad66854d7e69d049b18c
  table14 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m3 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Div
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
2193f15fe0288a7e3178434c7a8ad811
  table15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "/"#) -}
d1a6594e53c03725048d7c997788ffd5
  table16 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table17 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
89eb398aa46983158e2f651b00134d90
  table17 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m4 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Mul
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Mul
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
1ee617bbb060e7609b814bd5e4b5b3c5
  table18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "*"#) -}
72fc8505252f607becec427838338453
  table19 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table23 @ u)
                   (LexerTest.table20 @ u)) -}
67b83b2602fb701c43fa2c1be66a10fe
  table2 ::
    [[Text.Parsec.Expr.Operator
        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ [Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
                   (LexerTest.table3 @ u)
                   (GHC.Types.[]
                      @ [Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr])) -}
e6adcf958a322133bb26a26318f4fb4e
  table20 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table21 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
564654379a619e90d173147a71880465
  table21 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Prefix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table22 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))) -}
919ed37729790094649081468f964646
  table22 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m2 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      (GHC.Base.id @ LexerTest.Expr)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      (GHC.Base.id @ LexerTest.Expr)
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
c394441655113adff21b39681fcfa150
  table23 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Prefix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table24 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr>_R))) -}
9f4f62ca1201d363484a45cc89ea2641
  table24 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m1 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Neg
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
a9efadcc192cdbda7707451ed279ead6
  table3 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table8 @ u)
                   (LexerTest.table4 @ u)) -}
e420c719e4da2f24a61e4d62e8a53e72
  table4 ::
    [Text.Parsec.Expr.Operator
       GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr]
  {- Strictness: m2,
     Unfolding: (\ @ u ->
                 GHC.Types.:
                   @ (Text.Parsec.Expr.Operator
                        GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr)
                   (LexerTest.table5 @ u)
                   (GHC.Types.[]
                      @ (Text.Parsec.Expr.Operator
                           GHC.Base.String
                           u
                           Data.Functor.Identity.Identity
                           LexerTest.Expr))) -}
3b1cd208acd23181d1b2c1d75f8a59cd
  table5 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
5b4da7109e19670bdecb8c8529613d9a
  table6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m1 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Sub
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
01eac7e3e03dcbd890173499896906ba
  table7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-"#) -}
7b9b15cc8406e698bc04d6b8f1af22d4
  table8 ::
    Text.Parsec.Expr.Operator
      GHC.Base.String u Data.Functor.Identity.Identity LexerTest.Expr
  {- Strictness: m1,
     Unfolding: (\ @ u ->
                 Text.Parsec.Expr.Infix
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ LexerTest.Expr
                   (LexerTest.table9 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr>_R))
                   Text.Parsec.Expr.AssocLeft) -}
95a18740f60b10e449ee69d009a94eee
  table9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] u
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] u
                   eta1 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: (LexerTest.Expr -> LexerTest.Expr -> LexerTest.Expr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 (LexerTest.table_m2 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <()>_R)
                   @ b1
                   eta
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta1
                      LexerTest.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta2
                   (\ x :: ()
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] u
                      err :: Text.Parsec.Error.ParseError ->
                    eta3
                      LexerTest.Add
                      s2
                      (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                       case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                       case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                       case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                       case Text.Parsec.Error.$wmergeError
                              ww4
                              ww5
                              ww6
                              ww2
                              ww11
                              ww12
                              ww13
                              (GHC.Types.[]
                                 @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                       Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                   eta4) -}
2beb4db33d6b2888fbe84a3c193d69ed
  table_m1 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.back5
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table7 }) -}
594aee33625afb26e6953cab6c2f4a7a
  table_m2 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.back5
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table10 }) -}
60a4f971c0682b0c9fe7d4346f420624
  table_m3 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.back5
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table15 }) -}
69d7f96d94516875218896d30a63a86b
  table_m4 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] u Data.Functor.Identity.Identity ()
  {- Unfolding: (\ @ u ->
                 case LexerTest.back5
                        @ u of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds3 LexerTest.table18 }) -}
1cad9790977fbf049966d93890caa536
  term ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity LexerTest.Expr
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.back7
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Expr>_R)) -}
e1321788e1cb95b1898358120796e48a
  up :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.up1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
c469e5e7d92c65bd4af1f87790f97057
  up1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
1e8c0ce9005e2cefb36f892fcb6b351e
  var :: Text.Parsec.String.Parser LexerTest.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                LexerTest.var1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <LexerTest.Instr>_R)) -}
7a3ba6a3945eae96428c0ca48fc5832b
  var1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (LexerTest.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta1 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: LexerTest.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 case LexerTest.back5
                        @ () of wild { Text.Parsec.Token.TokenParser ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ->
                 ds
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Base.String>_R)
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.var2
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta2 (Text.Parsec.Error.mergeError err err')))
                   eta2
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    LexerTest.var2
                      x
                      @ b1
                      s2
                      eta1
                      eta2
                      (\ x1 :: LexerTest.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta4 (Text.Parsec.Error.mergeError err err')))
                   eta4 }) -}
fb8fb9fff25b9e273ae153769bb3cf9a
  var2 ::
    GHC.Base.String
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (LexerTest.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
instance GHC.Classes.Eq [LexerTest.Expr] = LexerTest.$fEqExpr
instance GHC.Classes.Eq [LexerTest.Instr] = LexerTest.$fEqInstr
instance GHC.Show.Show [LexerTest.Expr] = LexerTest.$fShowExpr
instance GHC.Show.Show [LexerTest.Instr] = LexerTest.$fShowInstr
"SPEC/LexerTest read @ Int" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                        GHC.Types.Int
  Text.Read.read @ GHC.Types.Int $dRead = LexerTest.$sread
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

