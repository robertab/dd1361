
==================== FINAL INTERFACE ====================
2016-05-05 11:04:25.852395 UTC

interface s4_CNAlJoOMahpLIiI8ONUcw6:Lexer 7103
  interface hash: 57798ed5fc822e6167661f52c90987e8
  ABI hash: 58b6e598819eb7b8c8190b029745ca6f
  export-list hash: 9d4205af9aa4c9ea6fe1c1883484cce2
  orphan hash: 5f96e7ef197ff2c6d1ebb081aa9c0cea
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lexer.back
  Lexer.color
  Lexer.comment
  Lexer.createTokens
  Lexer.down
  Lexer.expr
  Lexer.forw
  Lexer.instr
  Lexer.left
  Lexer.lexeme
  Lexer.lexer
  Lexer.mrep
  Lexer.num
  Lexer.rep
  Lexer.right
  Lexer.simpleWhitespace
  Lexer.term
  Lexer.up
  Lexer.var
  Lexer.whitespace
  Lexer.Expr{Lexer.Add Lexer.Div Lexer.Mul Lexer.Neg Lexer.Num Lexer.Sub}
  Lexer.Instr{Lexer.Back Lexer.Color Lexer.Down Lexer.Forw Lexer.LeftI Lexer.MRep Lexer.Rep Lexer.RightI Lexer.Up Lexer.Var}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl
                      text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
import  -/  base-4.8.2.0:Control.Applicative a8ebf5ad4932b411ad7725da68be9801
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map 1800ccac43fd924c376b60eac12f4d04
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec 26c7a351136ae5dd73df2f4f17f69ff8
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Char 273c4e73468dedca710570316c08a761
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Combinator 8d413b3f12710d25023c38cebce7eb58
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Error f845543d816de25a8de00e4137afe6b2
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Expr 74c953b1a60444019fbd97533fb68d31
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Language 050edbf20111bd6896772d23eab8c7e1
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Prim 1f699e694859aece3e0612a4d0e0177b
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.String 194037aaf0f54cd34cf205eead33954d
import  -/  parsec-3.1.9@parse_7aUabKPjr5W6Al5Ge35AQl:Text.Parsec.Token 08adccfb70cf8f729a4b2d5fc4848cbb
e25b42b90bcd8d6fc5b19afe41042740
  $fEqExpr :: GHC.Classes.Eq Lexer.Expr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Expr Lexer.$fEqExpr_$c== Lexer.$fEqExpr_$c/= -}
e25b42b90bcd8d6fc5b19afe41042740
  $fEqExpr_$c/= :: Lexer.Expr -> Lexer.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a13 :: Lexer.Expr b :: Lexer.Expr ->
                 case Lexer.$fEqExpr_$c== a13 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e25b42b90bcd8d6fc5b19afe41042740
  $fEqExpr_$c== :: Lexer.Expr -> Lexer.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fEqInstr :: GHC.Classes.Eq Lexer.Instr
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Instr Lexer.$fEqInstr_$c== Lexer.$fEqInstr_$c/= -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fEqInstr_$c/= :: Lexer.Instr -> Lexer.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a13 :: Lexer.Instr b :: Lexer.Instr ->
                 case Lexer.$fEqInstr_$c== a13 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fEqInstr_$c== :: Lexer.Instr -> Lexer.Instr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e25b42b90bcd8d6fc5b19afe41042740
  $fShowExpr :: GHC.Show.Show Lexer.Expr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Expr
                  Lexer.$fShowExpr_$cshowsPrec
                  Lexer.$fShowExpr_$cshow
                  Lexer.$fShowExpr_$cshowList -}
e25b42b90bcd8d6fc5b19afe41042740
  $fShowExpr1 :: Lexer.Expr -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Lexer.Expr -> Lexer.$w$cshowsPrec 0 w) -}
e25b42b90bcd8d6fc5b19afe41042740
  $fShowExpr_$cshow :: Lexer.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lexer.Expr ->
                 Lexer.$fShowExpr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e25b42b90bcd8d6fc5b19afe41042740
  $fShowExpr_$cshowList :: [Lexer.Expr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lexer.Expr Lexer.$fShowExpr1) -}
e25b42b90bcd8d6fc5b19afe41042740
  $fShowExpr_$cshowsPrec ::
    GHC.Types.Int -> Lexer.Expr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Lexer.Expr ->
                 case w of ww { GHC.Types.I# ww1 -> Lexer.$w$cshowsPrec ww1 w1 }) -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fShowInstr :: GHC.Show.Show Lexer.Instr
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Instr
                  Lexer.$fShowInstr_$cshowsPrec
                  Lexer.$fShowInstr_$cshow
                  Lexer.$fShowInstr_$cshowList -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fShowInstr1 :: Lexer.Instr -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Lexer.$fShowInstr_$cshowsPrec Lexer.$fShowInstr2) -}
d17e1effe2936f7c3e67c59198d8d611
  $fShowInstr2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fShowInstr_$cshow :: Lexer.Instr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lexer.Instr ->
                 Lexer.$fShowInstr_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fShowInstr_$cshowList :: [Lexer.Instr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.Instr
                   Lexer.$fShowInstr1) -}
87f5f9c6a8cc2d6163dc16c7a201a5c7
  $fShowInstr_$cshowsPrec ::
    GHC.Types.Int -> Lexer.Instr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
c29fa62b9c8ea85fa01ab4e104159dd9
  $s$fApplicativeParsecT ::
    GHC.Base.Applicative
      (Text.Parsec.Prim.ParsecT
         GHC.Base.String () Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Parsec.Prim.ParsecT
                       GHC.Base.String () Data.Functor.Identity.Identity)
                  (Text.Parsec.Prim.$fFunctorParsecT
                     @ GHC.Base.String
                     @ ()
                     @ Data.Functor.Identity.Identity)
                  (Text.Parsec.Prim.$fApplicativeParsecT_$cpure
                     @ GHC.Base.String
                     @ ()
                     @ Data.Functor.Identity.Identity
                     (Text.Parsec.Prim.$fFunctorParsecT
                        @ GHC.Base.String
                        @ ()
                        @ Data.Functor.Identity.Identity))
                  (Text.Parsec.Prim.$fApplicativeParsecT_$c<*>
                     @ GHC.Base.String
                     @ ()
                     @ Data.Functor.Identity.Identity
                     (Text.Parsec.Prim.$fFunctorParsecT
                        @ GHC.Base.String
                        @ ()
                        @ Data.Functor.Identity.Identity))
                  (Text.Parsec.Prim.$fApplicativeParsecT_$c*>
                     @ GHC.Base.String
                     @ ()
                     @ Data.Functor.Identity.Identity
                     (Text.Parsec.Prim.$fFunctorParsecT
                        @ GHC.Base.String
                        @ ()
                        @ Data.Functor.Identity.Identity))
                  (Text.Parsec.Prim.$fApplicativeParsecT_$c<*
                     @ GHC.Base.String
                     @ ()
                     @ Data.Functor.Identity.Identity
                     (Text.Parsec.Prim.$fFunctorParsecT
                        @ GHC.Base.String
                        @ ()
                        @ Data.Functor.Identity.Identity)) -}
6d435733881cf6f69b45e3917c880ea1
  $sread :: GHC.Base.String -> GHC.Types.Double
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 case Text.Read.readEither
                        @ GHC.Types.Double
                        GHC.Read.$fReadDouble
                        s of wild {
                   Data.Either.Left x -> GHC.Err.error @ GHC.Types.Double x
                   Data.Either.Right y -> y }) -}
e25b42b90bcd8d6fc5b19afe41042740
  $w$cshowsPrec :: GHC.Prim.Int# -> Lexer.Expr -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
1e07ecfe0a22d127c4f48e1a70711ee7
  $wa ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 4,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,1*C1(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b1
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = w1 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.comment7
                   @ b1
                   w
                   (\ x :: GHC.Base.String -> lvl50)
                   w3
                   (\ x :: GHC.Base.String[OneShot] ->
                    w2 (GHC.Base.id @ [GHC.Types.Char]))
                   w3) -}
d5a87a950fc42ffac6f3e2a26db16920
  $wa1 ::
    GHC.Base.String
    -> Text.Parsec.Pos.SourceName
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <L,U><L,U><L,U><L,U><S,U><L,C(C1(C1(U)))><L,C(U)>,
     Inline: [0],
     Unfolding: (\ @ u
                   @ b
                   ww :: GHC.Base.String
                   ww1 :: Text.Parsec.Pos.SourceName
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: u
                   w :: GHC.Types.Char
                        -> Text.Parsec.Prim.State GHC.Base.String u
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b
                   w1 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Char.$wa1
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.var7
                   @ b
                   ww
                   ww1
                   ww2
                   ww3
                   ww4
                   w
                   (\ err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Char.$wa
                      @ GHC.Base.String
                      @ u
                      @ Data.Functor.Identity.Identity
                      (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                      GHC.Unicode.isAlphaNum
                      @ b
                      ww
                      ww1
                      ww2
                      ww3
                      ww4
                      w
                      (\ err1 :: Text.Parsec.Error.ParseError ->
                       w1
                         (case err of ww5 { Text.Parsec.Error.ParseError ww6 ww7 ->
                          case ww6 of ww8 { Text.Parsec.Pos.SourcePos ww9 ww10 ww11 ->
                          case err1 of ww12 { Text.Parsec.Error.ParseError ww13 ww14 ->
                          case Text.Parsec.Prim.$wsetExpectErrors
                                 ww13
                                 ww14
                                 Lexer.var_msgs of ww15 { (#,#) ww16 ww17 ->
                          case ww16 of ww18 { Text.Parsec.Pos.SourcePos ww19 ww20 ww21 ->
                          case Text.Parsec.Error.$wmergeError
                                 ww9
                                 ww10
                                 ww11
                                 ww7
                                 ww19
                                 ww20
                                 ww21
                                 ww17 of ww22 { (#,#) ww23 ww24 ->
                          Text.Parsec.Error.ParseError ww23 ww24 } } } } } })))) -}
e25b42b90bcd8d6fc5b19afe41042740
  data Expr
    = Num GHC.Types.Double
    | Add Lexer.Expr Lexer.Expr
    | Sub Lexer.Expr Lexer.Expr
    | Mul Lexer.Expr Lexer.Expr
    | Div Lexer.Expr Lexer.Expr
    | Neg Lexer.Expr
87f5f9c6a8cc2d6163dc16c7a201a5c7
  data Instr
    = MRep Lexer.Expr [Lexer.Instr]
    | Color GHC.Base.String
    | Rep Lexer.Expr Lexer.Instr
    | Back Lexer.Expr
    | LeftI Lexer.Expr
    | RightI Lexer.Expr
    | Var GHC.Base.String Lexer.Expr
    | Down
    | Up
    | Forw Lexer.Expr
4b88dd22ff0401bc2bb381d5c41d537d
  back :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.back1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
44bf51766ae4171bf1c510b51e919e27
  back1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.back2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
78f1e2566c417d24205cf557d4912529
  back10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "back"#) -}
852bc1dee7073795048d1723f6f3c241
  back11 ::
    Text.Parsec.String.Parser a
    -> forall b1.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (a
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (a
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ a13
                   p :: Text.Parsec.String.Parser a13
                   @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: a13
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: a13
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ a13
                   (\ @ b2
                      s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      cok :: (() -> a13)
                             -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b2[OneShot]
                      cerr :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b2[OneShot]
                      eok :: (() -> a13)
                             -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b2[OneShot]
                      eerr :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b2[OneShot] ->
                    p `cast`
                    (Text.Parsec.Prim.NTCo:ParsecT[0]
                         <[GHC.Types.Char]>_R
                         <()>_R
                         <Data.Functor.Identity.Identity>_R
                         <a13>_R)
                      @ b2
                      s1
                      (\ x :: a13 -> cok (\ ds :: () -> x))
                      cerr
                      (\ x :: a13 -> eok (\ ds :: () -> x))
                      eerr)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> a13>_R))
                   Lexer.back12
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta
                   eta2
                   eta3
                   eta4
                   eta5) -}
11025020c6485374853fa7517f2a46c8
  back12 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta2 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta3 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   Lexer.back13
                   @ b
                   eta2
                   eta3
                   eta4
                   eta5
                   eta6) -}
3d775f6e9853ccfb589981c4b5f68f2f
  back13 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String () Data.Functor.Identity.Identity ()]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String () Data.Functor.Identity.Identity ())
                   Lexer.back18
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   Lexer.back14) -}
6850f155b12f2c4d1846b5049b2ed536
  back14 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String () Data.Functor.Identity.Identity ()]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String () Data.Functor.Identity.Identity ())
                   Lexer.back17
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   Lexer.back15) -}
04273c6cb40074589823b3fe9ff9c467
  back15 ::
    [Text.Parsec.Prim.ParsecT
       GHC.Base.String () Data.Functor.Identity.Identity ()]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Text.Parsec.Prim.ParsecT
                        GHC.Base.String () Data.Functor.Identity.Identity ())
                   Lexer.back16
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   (GHC.Types.[]
                      @ (Text.Parsec.Prim.ParsecT
                           GHC.Base.String () Data.Functor.Identity.Identity ()))) -}
cebc0f70551050b592d723923e625b9f
  back16 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(U,U,U)><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   ds :: ()
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   ds1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eok :: ()
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b ->
                 eok
                   GHC.Tuple.()
                   s1
                   (case s1 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                    Text.Parsec.Error.ParseError
                      ds4
                      (GHC.Types.[] @ Text.Parsec.Error.Message) })) -}
0f33c259f26809220c1d723082522b5f
  back17 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
29e765b16837be4f11c3313854982222
  back18 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
c6b24755739da0aa4f26ec67a2a85ba4
  back2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.back9
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.back5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.back3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.back3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
fba3022c457d9f42431e3b8b0a9ac801
  back3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.back4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.back4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
faf7e6e38e9db254585d9c0f9a9cdc16
  back4 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
e790beb6ca0e717fcca834fb1ef7b9b8
  back5 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   eta2 :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta3 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.back6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b
                   eta2
                   eta3
                   eta4
                   eta5
                   eta6) -}
4f9a545fd16715c6743b9f0ba9aee532
  back6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.back8
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Lexer.back7
                   @ b
                   eta
                   eta2
                   eta3
                   eta4
                   eta5) -}
8e40a9c7c381084d54506ec31f1264ed
  back7 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.space2
                   (GHC.Types.[] @ GHC.Base.String)) -}
8c3cbbde215d0bf4b231d6258a796b1f
  back8 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isSpace
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
ae79baf9c831b9d07a4171791c75e119
  back9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.back10
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] ->
                    eta5 (GHC.Base.id @ [GHC.Types.Char]))
                   eta6) -}
ca681c0d285a7a4d88a5de925993fb52
  color :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.color1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
f4a20bdf2ddd441bfaa57b777a00f013
  color1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.color2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
17fd76cafcc028911e78e2ebe2dd2612
  color10 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '#') -}
484bead59df6c9ce6f670f600f6e17c3
  color11 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ ()
                   Lexer.color12
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> ()>_R))
                   Lexer.back12
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
1bd9942c7691756d79eb71e66b29a900
  color12 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ ())
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.color13
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] -> eta5 (GHC.Base.id @ ()))
                   eta6) -}
e24fdc6b4ac4616b30ebaa105f066bf2
  color13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "color"#) -}
bed9f1a57c72a727c8d97a0c09a64df8
  color2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Lexer.color11
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char -> GHC.Types.Char>_R))
                   Lexer.color9
                   @ b1
                   eta
                   (\ x :: GHC.Types.Char
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.color3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: GHC.Types.Char
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.color3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
beff78ab188858fc243081df07622f1e
  color3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.color5
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <[GHC.Types.Char]>_R)
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.color4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.color4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
0305e611d6815733b0723a16cb915b8f
  color4 ::
    [GHC.Types.Char]
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
24e2896a8f8408df9febe5e41c84c4b5
  color5 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity [GHC.Types.Char]
  {- Unfolding: (Text.Parsec.Combinator.$wlvl
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   6
                   Lexer.color6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))) -}
30c07aff900819c52aec58060f47ab92
  color6 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.color8
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Lexer.color7
                   @ b
                   eta
                   eta2
                   eta3
                   eta4
                   eta5) -}
aac5e3e5f56490cf750d356a4c6bf6e6
  color7 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.hexDigit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
d1ec444903b39c965e0bb42d51717021
  color8 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isHexDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
598c469ffcd2e9482574ed0692480870
  color9 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.color10) -}
b7f29a298005d503e436bc80baa2ee3f
  comment ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity ()
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.comment1
                  `cast`
                (forall u.
                 Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <u>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
7d51942d11c1d6e82ead3f4e6aa1ce35
  comment1 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta2 :: Text.Parsec.Prim.State GHC.Base.String u
                   eta3 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 GHC.Tuple.()
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 GHC.Tuple.()
                 } in
                 Text.Parsec.Prim.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   (Lexer.comment6 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   (Lexer.comment2 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta2
                   (\ x :: [GHC.Types.Char] -> lvl51)
                   eta4
                   (\ x :: [GHC.Types.Char] -> lvl50)
                   eta6) -}
56b46daccc90e399771e28280a80eaf2
  comment2 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w3 :: Text.Parsec.Prim.State GHC.Base.String u
                   w4 :: [GHC.Types.Char]
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w6 :: [GHC.Types.Char]
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Combinator.$wa7
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ ()
                   @ GHC.Types.Char
                   (Lexer.comment5 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Lexer.comment3 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
6b68dc3ef0d03855648f1ea36360d2bd
  comment3 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(U)><L,C(U)>,
     Unfolding: (\ @ u
                   @ b
                   eta2 :: Text.Parsec.Prim.State GHC.Base.String u
                   eta3 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError -> Data.Functor.Identity.Identity b
                   = eta5 GHC.Tuple.()
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError -> Data.Functor.Identity.Identity b
                   = eta3 GHC.Tuple.()
                 } in
                 (Lexer.comment_eta1 @ u)
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <GHC.Base.String>_R
                      <u>_R
                      <Data.Functor.Identity.Identity>_R
                      <GHC.Types.Char>_R)
                   @ b
                   eta2
                   (\ x :: GHC.Types.Char -> lvl51)
                   eta4
                   (\ x :: GHC.Types.Char -> lvl50)
                   (\ err :: Text.Parsec.Error.ParseError ->
                    Text.Parsec.Combinator.eof1
                      @ GHC.Base.String
                      @ u
                      @ Data.Functor.Identity.Identity
                      @ GHC.Types.Char
                      (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                      GHC.Show.$fShowChar
                      @ b
                      eta2
                      eta3
                      eta4
                      (\ y :: ()
                         s' :: Text.Parsec.Prim.State GHC.Base.String u[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta5 y s' (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta6 (Text.Parsec.Error.mergeError err err')))) -}
37710f27ceadfb674b94e5a928fea2fa
  comment4 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '\n') -}
d568279736825eb35d57946ddd1a6f09
  comment5 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String u
                   eta2 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 case eta of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Text.Parsec.Char.anyChar2
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   eta2
                   eta5 } }) -}
2bebc176e29b9bf3770b58ed55f143f2
  comment6 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ @ u
                   @ b1
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Lexer.$wa @ u @ b1 w w1 w3 w4) -}
fea23bfa80865bdddb138278fba7c644
  comment7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%"#) -}
9ed9563898a97d286238f6279d5458ca
  comment_eta1 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (\ @ u ->
                 Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.comment4) -}
c12600a5d38e32b99ca208dae108e9ad
  createTokens ::
    GHC.Base.String
    -> Data.Either.Either Text.Parsec.Error.ParseError [Lexer.Instr]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.createTokens1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Data.Functor.Identity.NTCo:Identity[0]
                          <Data.Either.Either
                             Text.Parsec.Error.ParseError [Lexer.Instr]>_R) -}
8287871344aad8b71e69c53265352d8e
  createTokens1 ::
    GHC.Base.String
    -> Data.Functor.Identity.Identity
         (Data.Either.Either Text.Parsec.Error.ParseError [Lexer.Instr])
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s1 :: GHC.Base.String ->
                 Text.Parsec.Prim.runPT
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [Lexer.Instr]
                   @ GHC.Types.Char
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.createTokens2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Lexer.Instr]>_R))
                   GHC.Tuple.()
                   (GHC.Types.[] @ GHC.Types.Char)
                   s1) -}
c275439186f9ceb4a7c6562f0e209df1
  createTokens2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ([Lexer.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([Lexer.Instr]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: [Lexer.Instr]
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: [Lexer.Instr]
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ [Lexer.Instr]
                   Lexer.createTokens4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> [Lexer.Instr]>_R))
                   Lexer.createTokens3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
acb4d25f1c1e8fe07fa1b44db9094950
  createTokens3 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Combinator.eof1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Show.$fShowChar) -}
958e78a4583ff9d757d66d841f55452a
  createTokens4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> [Lexer.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> [Lexer.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (() -> [Lexer.Instr])
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (() -> [Lexer.Instr])
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [Lexer.Instr]
                   @ [Lexer.Instr]
                   Lexer.createTokens7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[Lexer.Instr] -> [Lexer.Instr]>_R))
                   Lexer.createTokens5
                   @ b1
                   s1
                   (\ x :: [Lexer.Instr] -> cok (\ ds :: () -> x))
                   cerr
                   (\ x :: [Lexer.Instr] -> eok (\ ds :: () -> x))
                   eerr) -}
6eecb47c5c70e0d27a2b52143fbc6578
  createTokens5 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity [Lexer.Instr]
  {- Unfolding: (Text.Parsec.Prim.$fAlternativeParsecT_$cmany
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   Lexer.$s$fApplicativeParsecT
                   @ Lexer.Instr
                   Lexer.createTokens6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
75bc85e7bc0f7bd6995ab6f1d38f0656
  createTokens6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
505fb7abd9b9ecff1dfa50a02f70f124
  createTokens7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([Lexer.Instr] -> [Lexer.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([Lexer.Instr] -> [Lexer.Instr])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,C(U)><L,U><L,C(U)><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([Lexer.Instr] -> [Lexer.Instr])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([Lexer.Instr] -> [Lexer.Instr])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ [Lexer.Instr])
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [Lexer.Instr])
                 } in
                 Text.Parsec.Combinator.choice3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   Lexer.back13
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
ece035a0524693eb4e2581dc4c5b3baf
  down :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.down1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
685ae96b3af7bba76db14de19180b7dd
  down1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.down2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
e0830970d70fdc7992bd2c2ed64cc00f
  down10 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ ())
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.down11
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] -> eta5 (GHC.Base.id @ ()))
                   eta6) -}
be369fe77716e8b61239f7c7342bfb9d
  down11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "down"#) -}
c812b33fec9302e1dd4ee1ca829c6df2
  down2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ Lexer.Instr
                   @ Lexer.Instr
                   Lexer.down4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr -> Lexer.Instr>_R))
                   Lexer.down3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
865ca7ae62a619a574882b0aa4cb8b79
  down3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(U,U,U)><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   ds :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   ds1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eok :: Lexer.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b ->
                 eok
                   Lexer.Down
                   s1
                   (case s1 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                    Text.Parsec.Error.ParseError
                      ds4
                      (GHC.Types.[] @ Text.Parsec.Error.Message) })) -}
ddc208dac606d336bd3bffe171b882ac
  down4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((Lexer.Instr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((Lexer.Instr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (Lexer.Instr -> Lexer.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (Lexer.Instr -> Lexer.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ Lexer.Instr)
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ Lexer.Instr)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ ()
                   Lexer.down6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> ()>_R))
                   Lexer.down5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
b8e660757706573da1219a4e6452f714
  down5 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (Text.Parsec.Char.spaces1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)) -}
2112c07830914e90e9ccf3edd8996a47
  down6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ ())
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ ())
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Lexer.down9
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char -> GHC.Types.Char>_R))
                   Lexer.down7
                   @ b1
                   eta2
                   (\ x :: GHC.Types.Char -> lvl51)
                   eta4
                   (\ x :: GHC.Types.Char -> lvl50)
                   eta6) -}
16149e922029f455588995b002ebf2ce
  down7 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity GHC.Types.Char
  {- Unfolding: (Text.Parsec.Char.char
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.down8) -}
5f32141ed794af9a4d2f69eab24a59c7
  down8 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# '.') -}
e5db717fcc0fd10a65c27c697bfd84d9
  down9 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ ()
                   Lexer.down10
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> ()>_R))
                   Lexer.down5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
7a79951f10db8ff042029aafff5d9844
  expr :: Text.Parsec.String.Parser Lexer.Expr
b27afcf312c40f18aca77a7fbbc36ae7
  forw :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.forw1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
764dc1cd6c2f536a502b6f621fb6749b
  forw1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.forw2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
741e98fe39381fa34a503bc9b4b6c33b
  forw2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.forw5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.back5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.forw3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.forw3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
397774cf2ddc39ab53f885f06a82cd86
  forw3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.forw4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.forw4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
cf1deb6679d20c76046c54707ec22e30
  forw4 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
15d788986d966605801d77851665032d
  forw5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.forw6
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] ->
                    eta5 (GHC.Base.id @ [GHC.Types.Char]))
                   eta6) -}
20c7ad0ac053aeb5a330e9d6aad49aad
  forw6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "forw"#) -}
1c0d78c3e9f991370f23ec02816cdbf6
  instr :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Strictness: <L,U(U,U,U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Lexer.createTokens6
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
606e23dacc91075fbe00c37a03d184f4
  left :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.left1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
34f9852864ab63094a671c5c17141035
  left1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.left2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
f05308b4227d28f5f15280e1fddf80a6
  left2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.left5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.back5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.left3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.left3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
40670aaa2e502f594c95f6132fa922fb
  left3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.left4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.left4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
143e0a7df7bf163dc6eeb5efe11f6d1b
  left4 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
903431bd9fbb94aebb1a649f1092042b
  left5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.left6
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] ->
                    eta5 (GHC.Base.id @ [GHC.Types.Char]))
                   eta6) -}
3df3cc4d1b4cf0961b991c7eecaec5cd
  left6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "left"#) -}
7af10daac9bbd9433ccd082a0ba33920
  lexeme ::
    Text.Parsec.String.Parser a -> Text.Parsec.String.Parser a
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.back11
                  `cast`
                (forall a13.
                 <Text.Parsec.String.Parser a13>_R
                 ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <[GHC.Types.Char]>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <a13>_R)) -}
c0fa981cf642a737491149da110ae600
  lexer :: Text.Parsec.Token.TokenParser ()
  {- Unfolding: (Text.Parsec.Token.makeTokenParser
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.lexer1) -}
1c3bb915f12a06b7be18675b6c698c18
  lexer1 ::
    Text.Parsec.Token.GenLanguageDef
      GHC.Base.String () Data.Functor.Identity.Identity
  {- Unfolding: (Text.Parsec.Token.LanguageDef
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   Text.Parsec.Language.javaStyle4
                   Text.Parsec.Language.javaStyle3
                   Text.Parsec.Language.javaStyle2
                   GHC.Types.True
                   (Text.Parsec.Language.haskellDef82 @ ())
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (Text.Parsec.Language.javaStyle1 @ ())
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Lexer.lexer2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Lexer.lexer2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (GHC.Types.[] @ GHC.Base.String)
                   (GHC.Types.[] @ GHC.Base.String)
                   GHC.Types.False) -}
7f440c10c40e846149cd717fd7b63ebc
  lexer2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta4 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot]
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b[OneShot] ->
                 case eta of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.lexer3
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   eta2
                   eta5 } }) -}
33c750c15832bd0f68a07af37c4035c0
  lexer3 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   Lexer.lexer_cs) -}
d8e3f83d45f9de93c2c78e977ba80463
  lexer_cs :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "+-*/"#) -}
c88e4d1b3476c7d22c09a96b4ed2668c
  mrep :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.mrep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
bf80b19dec3c78fa2bab50218b2a56a6
  mrep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.mrep2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
d3fdd23237ac6ff1ac6785f4ff5dfa4e
  mrep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.mrep6
                   @ b1
                   eta
                   (\ x :: GHC.Base.String
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.mrep3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: GHC.Base.String[OneShot]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.mrep3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
4aaf4456cbc4f429dfd0b354559046d2
  mrep3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.back6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.mrep4
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.mrep4
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
a00951d15dc52148bc1eb46ab3b27288
  mrep4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.mrep5
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.mrep5
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
fabc0fafb8b2e09e314a6d14fa22396c
  mrep5 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
1d951dbdc6aeaa6528b384c16b5e6a51
  mrep6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rep"#) -}
567c3186cf8830d78b59390ae2ef12aa
  num :: Text.Parsec.String.Parser Lexer.Expr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.num1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Expr>_R)) -}
dfb0b2ac4a57a7340f08bf31fbbfaeb6
  num1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: Lexer.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: Lexer.Expr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.num2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (Lexer.Num (Lexer.$sread x)))
                   cerr
                   (\ x :: GHC.Base.String -> eok (Lexer.Num (Lexer.$sread x)))
                   eerr) -}
6d98d46ce69bacd6a5dd86d41c0c2177
  num2 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b
                   eta :: Text.Parsec.Prim.State GHC.Base.String ()
                   eta2 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State GHC.Base.String ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 Text.Parsec.Prim.<?>2
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   Lexer.num4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   Lexer.num3
                   @ b
                   eta
                   eta2
                   eta3
                   eta4
                   eta5) -}
f09bd967876b9861bc4df6cfab4ac82c
  num3 :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.digit2
                   (GHC.Types.[] @ GHC.Base.String)) -}
bcd9fe75d0d5e6e12b862105cc583f7e
  num4 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Unfolding: (\ @ b
                   w2 :: Text.Parsec.Prim.State GHC.Base.String ()[OneShot]
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w5 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot]
                   w6 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b[OneShot] ->
                 case w2 of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   GHC.Unicode.isDigit
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w3
                   w6 } }) -}
86724224d98d9519bbbe248f94131e5d
  rep :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.rep1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
ae7012d3ea00c6aba6bb9791f40207f8
  rep1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.rep2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
2a82ce48e9ab5feded14b6db89ee9319
  rep2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.rep5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.back5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.rep3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.rep3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
ca3b036c1876e184b33bc9c51aea20a3
  rep3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.rep4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.rep4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
2171041f8e3344070a635c1482561424
  rep4 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
c9a2356f5a8165f4451e18e7461fc960
  rep5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.mrep6
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] ->
                    eta5 (GHC.Base.id @ [GHC.Types.Char]))
                   eta6) -}
5df67fd704078c6091bbece2187c40bb
  right :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.right1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
89d0a755ad8269b505cd80e521c0d599
  right1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.right2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
eaf086f7b22742712b0d530bf2c20640
  right2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.right5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.back5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   eta
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.right3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: [GHC.Types.Char]
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                      err :: Text.Parsec.Error.ParseError[OneShot] ->
                    Lexer.right3
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
526b2a8206366aae9962ab5f050dd4df
  right3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta2 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Lexer.Instr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.expr
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b1
                   eta
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.right4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta2 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta3 (Text.Parsec.Error.mergeError err err')))
                   eta3
                   (\ x :: Lexer.Expr
                      s2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                      err :: Text.Parsec.Error.ParseError ->
                    Lexer.right4
                      x
                      @ b1
                      s2
                      eta2
                      eta3
                      (\ x1 :: Lexer.Instr
                         s3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta4 x1 s3 (Text.Parsec.Error.mergeError err err'))
                      (\ err' :: Text.Parsec.Error.ParseError ->
                       eta5 (Text.Parsec.Error.mergeError err err')))
                   eta5) -}
ca4de41a625513bbcaf34e6d24a7b4b1
  right4 ::
    Lexer.Expr
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] ()
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Lexer.Instr
           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
4c119c395ffd3e9723396314b719d9ee
  right5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ [GHC.Types.Char])
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.right6
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] ->
                    eta5 (GHC.Base.id @ [GHC.Types.Char]))
                   eta6) -}
67a2c5b6096b9bb045a19e2faca41cb5
  right6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "right"#) -}
4e626f6ae646405c39d9c3fe9369407f
  simpleWhitespace ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String u Data.Functor.Identity.Identity ()
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.simpleWhitespace1
                  `cast`
                (forall u.
                 Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <u>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
b8e088354976d8832bcfb9763fa45cd9
  simpleWhitespace1 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ u
                   @ b1
                   eta2 :: Text.Parsec.Prim.State GHC.Base.String u
                   eta3 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: ()
                           -> Text.Parsec.Prim.State GHC.Base.String u
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 GHC.Tuple.()
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State GHC.Base.String u
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 GHC.Tuple.()
                 } in
                 Text.Parsec.Combinator.many3
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   (Lexer.simpleWhitespace2 @ u)
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <u>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   @ b1
                   eta2
                   (\ x :: [GHC.Types.Char] -> lvl51)
                   eta4
                   (\ x :: [GHC.Types.Char] -> lvl50)
                   eta6) -}
e656fb0a988f4bf67d3a49d478651af9
  simpleWhitespace2 ::
    Text.Parsec.Prim.State GHC.Base.String u
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String u
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ u
                   @ b
                   w :: Text.Parsec.Prim.State GHC.Base.String u
                   w1 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w3 :: GHC.Types.Char
                         -> Text.Parsec.Prim.State GHC.Base.String u
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wa
                   @ GHC.Base.String
                   @ u
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.simpleWhitespace3
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   w1
                   w4 } }) -}
ef20d33125f166adc2de5888d26457a2
  simpleWhitespace3 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (\ c :: GHC.Types.Char ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   c
                   Lexer.simpleWhitespace_cs) -}
aeb14c8a625c4a2d8b386f9a2b3b8fda
  simpleWhitespace_cs :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " \t\n"#) -}
8f110b22132a8b06f9a6f3bc76a17416
  term :: Text.Parsec.String.Parser Lexer.Expr
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Lexer.term1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Expr>_R)) -}
b53c35da10abb663e5f2522bb6f1d29a
  term1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Lexer.Expr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)>,
     Unfolding: (\ @ b
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: Lexer.Expr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta5 :: Lexer.Expr
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                 let {
                   lvl50 :: GHC.Base.String
                            -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     {- Arity: 1 -}
                   = \ x :: GHC.Base.String -> eta3 (Lexer.Num (Lexer.$sread x))
                 } in
                 Lexer.term2
                   `cast`
                 (Text.Parsec.Prim.NTCo:ParsecT[0]
                      <[GHC.Types.Char]>_R
                      <()>_R
                      <Data.Functor.Identity.Identity>_R
                      <Lexer.Expr>_R)
                   @ b
                   eta2
                   eta3
                   eta4
                   eta5
                   (\ err :: Text.Parsec.Error.ParseError ->
                    let {
                      eerr :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b
                        {- Arity: 1, Strictness: <L,1*U(U(U,U,U),U)>,
                           Unfolding: InlineRule (1, True, False)
                                      (\ err' :: Text.Parsec.Error.ParseError ->
                                       eta6 (Text.Parsec.Error.mergeError err err')) -}
                      = \ err' :: Text.Parsec.Error.ParseError ->
                        eta6 (Text.Parsec.Error.mergeError err err')
                    } in
                    Text.Parsec.Combinator.many3
                      @ GHC.Base.String
                      @ ()
                      @ Data.Functor.Identity.Identity
                      @ GHC.Types.Char
                      Lexer.num2
                        `cast`
                      (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                <GHC.Base.String>_R
                                <()>_R
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Char>_R))
                      @ b
                      eta2
                      lvl50
                      eerr
                      (\ x :: GHC.Base.String
                         s' :: Text.Parsec.Prim.State [GHC.Types.Char] ()[OneShot]
                         err' :: Text.Parsec.Error.ParseError[OneShot] ->
                       eta5
                         (Lexer.Num (Lexer.$sread x))
                         s'
                         (Text.Parsec.Error.mergeError err err'))
                      eerr)) -}
2e3c9a05f20ecd5b0b5e63d349038a8a
  term2 ::
    Text.Parsec.Prim.ParsecT
      GHC.Base.String () Data.Functor.Identity.Identity Lexer.Expr
  {- Unfolding: (case Lexer.lexer of wild { Text.Parsec.Token.TokenParser ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ->
                 ds17 @ Lexer.Expr Lexer.expr }) -}
f4d0642d6a7165eaf2207fb37499e136
  up :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Unfolding: InlineRule (0, True, True)
                Lexer.up1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
3105b48c4c1b11710e97123a8835dabc
  up1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Unfolding: (Lexer.back11
                   @ Lexer.Instr
                   Lexer.up2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))) -}
907d21f063e9c340571aff6557d82557
  up2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ Lexer.Instr
                   @ Lexer.Instr
                   Lexer.up4
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr -> Lexer.Instr>_R))
                   Lexer.up3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Instr>_R))
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
3b8853b5e859241853c8777f01f89b5a
  up3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(U,U,U)><L,A><L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,A>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   ds :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b
                   ds1 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   eok :: Lexer.Instr
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b
                   ds2 :: Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b ->
                 eok
                   Lexer.Up
                   s1
                   (case s1 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                    Text.Parsec.Error.ParseError
                      ds4
                      (GHC.Types.[] @ Text.Parsec.Error.Message) })) -}
29acd4ec87aca7d0cfe2eebe0969c40c
  up4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((Lexer.Instr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((Lexer.Instr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (Lexer.Instr -> Lexer.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (Lexer.Instr -> Lexer.Instr)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ Lexer.Instr)
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ Lexer.Instr)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ ()
                   Lexer.up5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> ()>_R))
                   Lexer.down5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
1bc940ad082e5ef5bc6cf64000033225
  up5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ ())
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ ())
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Lexer.up6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char -> GHC.Types.Char>_R))
                   Lexer.down7
                   @ b1
                   eta2
                   (\ x :: GHC.Types.Char -> lvl51)
                   eta4
                   (\ x :: GHC.Types.Char -> lvl50)
                   eta6) -}
7fbcd7c9232bb148d6ca168752035bb6
  up6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((GHC.Types.Char -> GHC.Types.Char)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (GHC.Types.Char -> GHC.Types.Char)
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta5 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 let {
                   lvl51 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ GHC.Types.Char)
                 } in
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ ()
                   @ ()
                   Lexer.up7
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <() -> ()>_R))
                   Lexer.down5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <()>_R))
                   @ b1
                   eta2
                   (\ x :: () -> lvl51)
                   eta4
                   (\ x :: () -> lvl50)
                   eta6) -}
82ee284cc5283b51efbeede30226931f
  up7 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((() -> ())
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,1*C1(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   eta2 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   eta3 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta5 :: (() -> ())
                           -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eta6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 let {
                   lvl50 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                   = eta3 (GHC.Base.id @ ())
                 } in
                 Text.Parsec.Char.string1
                   @ GHC.Base.String
                   @ ()
                   @ Data.Functor.Identity.Identity
                   (Text.Parsec.String.$s$fStream[]mtok @ GHC.Types.Char)
                   Lexer.up8
                   @ b1
                   eta2
                   (\ x :: GHC.Base.String -> lvl50)
                   eta4
                   (\ x :: GHC.Base.String[OneShot] -> eta5 (GHC.Base.id @ ()))
                   eta6) -}
85ac92ae1eb04bca0431c7477d00a781
  up8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "up"#) -}
33f2e1dcbb5bc84d15ed5b11fbd49ba5
  var :: Text.Parsec.String.Parser Lexer.Instr
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lexer.var1
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <Lexer.Instr>_R)) -}
60d6a03f50269f8e47d1b915631dc6d1
  var1 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Lexer.Instr
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: Lexer.Instr
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ Lexer.Expr
                   @ Lexer.Instr
                   Lexer.var2
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <Lexer.Expr -> Lexer.Instr>_R))
                   Lexer.expr
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
080a9c0b1f4311d754a411002390dcd0
  var2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ((Lexer.Expr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ((Lexer.Expr -> Lexer.Instr)
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ @ b1
                   s1 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   cok :: (Lexer.Expr -> Lexer.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   cerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1
                   eok :: (Lexer.Expr -> Lexer.Instr)
                          -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b1
                   eerr :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b1 ->
                 Lexer.back11
                   @ [GHC.Types.Char]
                   Lexer.var3
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))
                   @ b1
                   s1
                   (\ x :: GHC.Base.String -> cok (Lexer.Var x))
                   cerr
                   (\ x :: GHC.Base.String -> eok (Lexer.Var x))
                   eerr) -}
58e3460acf46813837d7350185a23fbd
  var3 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w3 :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w4 :: [GHC.Types.Char]
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w5 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w6 :: [GHC.Types.Char]
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w7 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 Text.Parsec.Prim.$wa
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Lexer.var6
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char] -> [GHC.Types.Char]>_R))
                   Lexer.var4
                   @ b1
                   w3
                   w4
                   w5
                   w6
                   w7) -}
74d1baa397e678d4db043cea4ac72e44
  var4 ::
    Text.Parsec.Prim.ParsecT
      [GHC.Types.Char] () Data.Functor.Identity.Identity [GHC.Types.Char]
  {- Unfolding: (Text.Parsec.Prim.$fAlternativeParsecT_$cmany
                   @ [GHC.Types.Char]
                   @ ()
                   @ Data.Functor.Identity.Identity
                   Lexer.$s$fApplicativeParsecT
                   @ GHC.Types.Char
                   Lexer.var5
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <GHC.Base.String>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))) -}
88e9f04de8643a5f3d06362d5f509dfe
  var5 ::
    Text.Parsec.Prim.State GHC.Base.String ()
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State GHC.Base.String ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5 -}
7dcd8591ca2aa9b0fba44869e8dfce5d
  var6 ::
    Text.Parsec.Prim.State [GHC.Types.Char] ()
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (([GHC.Types.Char] -> [GHC.Types.Char])
        -> Text.Parsec.Prim.State [GHC.Types.Char] ()
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(LSS),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ b1
                   w :: Text.Parsec.Prim.State [GHC.Types.Char] ()
                   w1 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w2 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w3 :: ([GHC.Types.Char] -> [GHC.Types.Char])
                         -> Text.Parsec.Prim.State [GHC.Types.Char] ()
                         -> Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1
                   w4 :: Text.Parsec.Error.ParseError
                         -> Data.Functor.Identity.Identity b1 ->
                 case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Lexer.$wa1
                   @ ()
                   @ b1
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   (\ x :: GHC.Types.Char -> w1 (GHC.Types.: @ GHC.Types.Char x))
                   w4 } }) -}
0e910c7fe66748c716145b131fb665ed
  var7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "0123456789\n\
                   \ \t\r%.+-*\\()="#) -}
96ec11712d38918ce0c7e1e2af2b1181
  var_msgs :: [GHC.Base.String]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   Text.Parsec.Char.alphaNum2
                   (GHC.Types.[] @ GHC.Base.String)) -}
18a1ab88129c33c046aa391a9049a765
  whitespace :: Text.Parsec.String.Parser ()
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><L,U><L,U><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Lexer.back12
                  `cast`
                (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                          <GHC.Base.String>_R
                          <()>_R
                          <Data.Functor.Identity.Identity>_R
                          <()>_R)) -}
instance GHC.Classes.Eq [Lexer.Expr] = Lexer.$fEqExpr
instance GHC.Classes.Eq [Lexer.Instr] = Lexer.$fEqInstr
instance GHC.Show.Show [Lexer.Expr] = Lexer.$fShowExpr
instance GHC.Show.Show [Lexer.Instr] = Lexer.$fShowInstr
"SPEC/Lexer $fApplicativeParsecT @ String @ () @ Identity" [ALWAYS] forall $dFunctor :: GHC.Base.Functor
                                                                                          (Text.Parsec.Prim.ParsecT
                                                                                             GHC.Base.String
                                                                                             ()
                                                                                             Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fApplicativeParsecT @ [GHC.Types.Char]
                                        @ ()
                                        @ Data.Functor.Identity.Identity
                                        $dFunctor
  = Lexer.$s$fApplicativeParsecT
"SPEC/Lexer read @ Double" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                       GHC.Types.Double
  Text.Read.read @ GHC.Types.Double $dRead = Lexer.$sread
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

